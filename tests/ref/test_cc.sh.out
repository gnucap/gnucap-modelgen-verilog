/* This file is automatically generated. DO NOT EDIT */
/*--------------------------------------------------------------------------*/
#include <globals.h>
#include <e_compon.h>
#include <e_subckt.h>
#include <e_node.h>
#include <e_elemnt.h>
// #include <e_paramlist.h>
#include <u_nodemap.h>
#include "../m_va.h"
#include "../e_va.h"
/*--------------------------------------------------------------------------*/
const double NA(NOT_INPUT);
const double INF(BIGBIG);
/*--------------------------------------------------------------------------*/
namespace {
/*--------------------------------------------------------------------------*/
class NATURE_Current : public NATURE {
  double abstol()const override {return 1e-12;}
}_N_Current;
class NATURE_Charge : public NATURE {
  double abstol()const override {return 1e-14;}
}_N_Charge;
class NATURE_Voltage : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Voltage;
class NATURE_Flux : public NATURE {
  double abstol()const override {return 1e-9;}
}_N_Flux;
class NATURE_Magneto_Motive_Force : public NATURE {
  double abstol()const override {return 1e-12;}
}_N_Magneto_Motive_Force;
class NATURE_Temperature : public NATURE {
  double abstol()const override {return 1e-4;}
}_N_Temperature;
class NATURE_Power : public NATURE {
  double abstol()const override {return 1e-9;}
}_N_Power;
class NATURE_Position : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Position;
class NATURE_Velocity : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Velocity;
class NATURE_Acceleration : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Acceleration;
class NATURE_Impulse : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Impulse;
class NATURE_Force : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Force;
class NATURE_Angle : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angle;
class NATURE_Angular_Velocity : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Velocity;
class NATURE_Angular_Acceleration : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Acceleration;
class NATURE_Angular_Force : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Force;
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
class DISCIPLINE_electrical : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Current;
  }
  NATURE const* potential()const override{
    return &_N_Voltage;
  }
}_D_electrical;
class _COMMON_VASRC_electrical : public COMMON_VASRC {
public:
  _COMMON_VASRC_electrical(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_electrical(_COMMON_VASRC_electrical const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_electrical(*this);
  }
  std::string name()const override{untested(); return "electrical";}
  DISCIPLINE const* discipline()const override {return &_D_electrical;}
public:
};
static _COMMON_VASRC_electrical _C_V_electrical(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_voltage : public DISCIPLINE {
public:
  NATURE const* potential()const override{
    return &_N_Voltage;
  }
}_D_voltage;
class _COMMON_VASRC_voltage : public COMMON_VASRC {
public:
  _COMMON_VASRC_voltage(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_voltage(_COMMON_VASRC_voltage const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_voltage(*this);
  }
  std::string name()const override{untested(); return "voltage";}
  DISCIPLINE const* discipline()const override {return &_D_voltage;}
public:
};
static _COMMON_VASRC_voltage _C_V_voltage(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_current : public DISCIPLINE {
public:
  NATURE const* potential()const override{
    return &_N_Current;
  }
}_D_current;
class _COMMON_VASRC_current : public COMMON_VASRC {
public:
  _COMMON_VASRC_current(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_current(_COMMON_VASRC_current const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_current(*this);
  }
  std::string name()const override{untested(); return "current";}
  DISCIPLINE const* discipline()const override {return &_D_current;}
public:
};
static _COMMON_VASRC_current _C_V_current(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_magnetic : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Flux;
  }
  NATURE const* potential()const override{
    return &_N_Magneto_Motive_Force;
  }
}_D_magnetic;
class _COMMON_VASRC_magnetic : public COMMON_VASRC {
public:
  _COMMON_VASRC_magnetic(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_magnetic(_COMMON_VASRC_magnetic const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_magnetic(*this);
  }
  std::string name()const override{untested(); return "magnetic";}
  DISCIPLINE const* discipline()const override {return &_D_magnetic;}
public:
};
static _COMMON_VASRC_magnetic _C_V_magnetic(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_thermal : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Power;
  }
  NATURE const* potential()const override{
    return &_N_Temperature;
  }
}_D_thermal;
class _COMMON_VASRC_thermal : public COMMON_VASRC {
public:
  _COMMON_VASRC_thermal(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_thermal(_COMMON_VASRC_thermal const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_thermal(*this);
  }
  std::string name()const override{untested(); return "thermal";}
  DISCIPLINE const* discipline()const override {return &_D_thermal;}
public:
};
static _COMMON_VASRC_thermal _C_V_thermal(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_kinematic : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Force;
  }
  NATURE const* potential()const override{
    return &_N_Position;
  }
}_D_kinematic;
class _COMMON_VASRC_kinematic : public COMMON_VASRC {
public:
  _COMMON_VASRC_kinematic(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_kinematic(_COMMON_VASRC_kinematic const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_kinematic(*this);
  }
  std::string name()const override{untested(); return "kinematic";}
  DISCIPLINE const* discipline()const override {return &_D_kinematic;}
public:
};
static _COMMON_VASRC_kinematic _C_V_kinematic(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_kinematic_v : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Force;
  }
  NATURE const* potential()const override{
    return &_N_Velocity;
  }
}_D_kinematic_v;
class _COMMON_VASRC_kinematic_v : public COMMON_VASRC {
public:
  _COMMON_VASRC_kinematic_v(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_kinematic_v(_COMMON_VASRC_kinematic_v const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_kinematic_v(*this);
  }
  std::string name()const override{untested(); return "kinematic_v";}
  DISCIPLINE const* discipline()const override {return &_D_kinematic_v;}
public:
};
static _COMMON_VASRC_kinematic_v _C_V_kinematic_v(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_rotational : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Angular_Force;
  }
  NATURE const* potential()const override{
    return &_N_Angle;
  }
}_D_rotational;
class _COMMON_VASRC_rotational : public COMMON_VASRC {
public:
  _COMMON_VASRC_rotational(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_rotational(_COMMON_VASRC_rotational const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_rotational(*this);
  }
  std::string name()const override{untested(); return "rotational";}
  DISCIPLINE const* discipline()const override {return &_D_rotational;}
public:
};
static _COMMON_VASRC_rotational _C_V_rotational(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_rotational_omega : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Angular_Force;
  }
  NATURE const* potential()const override{
    return &_N_Angular_Velocity;
  }
}_D_rotational_omega;
class _COMMON_VASRC_rotational_omega : public COMMON_VASRC {
public:
  _COMMON_VASRC_rotational_omega(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_rotational_omega(_COMMON_VASRC_rotational_omega const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_rotational_omega(*this);
  }
  std::string name()const override{untested(); return "rotational_omega";}
  DISCIPLINE const* discipline()const override {return &_D_rotational_omega;}
public:
};
static _COMMON_VASRC_rotational_omega _C_V_rotational_omega(CC_STATIC);
/*--------------------------------------------------------------------------*/
class MOD_resistor;
class COMMON_resistor :public COMMON_COMPONENT{
  typedef MOD_resistor MOD;
  typedef ddouble_<1> ddouble;
  enum {
    d_potential_b_p_n
  };
public:
public:
  explicit COMMON_resistor(const COMMON_resistor& p);
  explicit COMMON_resistor(int c=0);
           ~COMMON_resistor();
  bool     operator==(const COMMON_COMPONENT&)const;
  COMMON_COMPONENT* clone()const {return new COMMON_resistor(*this);}
  void     set_param_by_index(int, std::string&, int);
  bool     is_valid()const;
  bool     param_is_printable(int)const;
  std::string param_name(int)const;
  std::string param_name(int,int)const;
  std::string param_value(int)const;
  int param_count()const {return (1 + COMMON_COMPONENT::param_count());}
  void precalc_first(const CARD_LIST*);
  void expand(const COMPONENT*);
  void precalc_last(const CARD_LIST*);
  void tr_eval_analog(MOD_resistor*)const;
  std::string name()const {itested();return "resistor";}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<real> _p_r /*  */;
private: // analog functions
private: // tmp hack
  double temp_hack()const {
    return P_CELSIUS0 + _sim->_temp_c;
  }
  double vt_hack()const {
    return P_K * temp_hack() / P_Q;
  }
  double vt_hack(double T)const {
    assert(T>=-P_CELSIUS0);
    return P_K * temp_hack() / P_Q;
  }
  bool param_given(PARA_BASE const& p)const {
    return p.has_hard_value();
  }
};
/*--------------------------------------------------------------------------*/
class MOD_resistor : public BASE_SUBCKT {
private:
  static int _count;
public:
  typedef ddouble_<1> ddouble;
  enum {
    d_potential_b_p_n
  };
private: // data
  node_t _nodes[12];
public: // netlist
  ELEMENT* _b_p_n{NULL}; // branch
private: // construct
  explicit MOD_resistor(MOD_resistor const&);
public:
  explicit MOD_resistor(); // : BASE_SUBCKT() { _n = _nodes; }
  CARD* clone()const override;
private: // overrides
  bool is_valid()const override;
  void precalc_first();
  void expand();
  void precalc_last();
  //void    map_nodes();         //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
    void    tr_load(){ trace1("tr_load", long_label());BASE_SUBCKT::tr_load();}
  void      dc_advance()override {set_not_converged(); BASE_SUBCKT::dc_advance();}
  void      tr_advance()override {set_not_converged(); BASE_SUBCKT::tr_advance();}
  void      tr_regress()override {set_not_converged(); BASE_SUBCKT::tr_regress();}
  bool      tr_needs_eval()const override;
  void      tr_queue_eval()override {if(tr_needs_eval()){q_eval();}else{} }
  bool      do_tr() override;
  double tr_probe_num(std::string const&)const override;
  int max_nodes()const override {return 2;}
  int min_nodes()const override {return 2;}
  int int_nodes()const override    {return 0;}
  std::string value_name()const override {itested(); return "";}
  bool print_type_in_spice()const override {itested(); return false;}
  std::string port_name(int i)const override;
private: // impl
/* ========== */
public: // instance vars
private: // branch state
public: // states, _b_p_n;
  double _value_b_p_n;
  double _st_b_p_n  [2];
  struct _st_b_p_n_ {
    enum {     VALUE, SELF    };
  } _dep_b_p_n;
private: // filter state
private: // node list
  enum {n_p, n_n  };
private: // probe values
  double _potential_b_p_n;
private: // impl
  void read_probes();
  void set_branch_contributions();
  void clear_branch_contributions();
  friend class COMMON_resistor;
}; // m_resistor;
/*--------------------------------------------------------------------------*/
COMMON_resistor::COMMON_resistor(int c)
  :COMMON_COMPONENT(c),
   _p_r(/*default*/)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_resistor::COMMON_resistor(const COMMON_resistor& p)
  :COMMON_COMPONENT(p),
   _p_r(p._p_r)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_resistor::~COMMON_resistor()
{
  --_count;
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_resistor* p = dynamic_cast<const COMMON_resistor*>(&x);
  return (p
    && _p_r == p->_p_r
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_resistor::param_count() - 1 - I) {
  case 0:  _p_r = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::param_is_printable(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return (true);
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_name(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return "r";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_name(int i, int j)const
{
  if(j==0){
    return param_name(i);
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_value(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return _p_r.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::is_valid() const
{
  COMMON_resistor const* pc = this;
  (void)pc;
  {
  double lb, ub;
  {
  ddouble t0;
  t0 = 1e-8;
  lb = t0;
  }
  {
  ddouble t0;
  t0 = inf;
  ub = t0;
  }
  if(!(lb<=_p_r && _p_r<ub)){ return false; }else{ }
  }
  return true; //COMMON_COMPONENT::is_valid();
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 = 1.;
    real def = real(t0.value());
    e_val(&(this->_p_r),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 = 1.;
    real def = real(t0.value());
    e_val(&(this->_p_r),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int COMMON_resistor::_count = -1;
static COMMON_resistor Default_resistor(CC_STATIC);
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
double MOD_resistor::tr_probe_num(std::string const& n) const
{
  if(n == "v0") return _n[0].v0();
  if(n == "v1") return _n[1].v0();
  if(n == "v2") return _n[2].v0();
  if(n == "v3") return _n[3].v0();
  if(n == "i0") return (_value_b_p_n);
  if(n == "i0_d0") return (_st_b_p_n[0]);
  if(n == "i0_d1") return (_st_b_p_n[1]);
  if(n == "i0_d2") return (_st_b_p_n[2]);
  if(n == "i0_d3") return (_st_b_p_n[3]);
  return NOT_VALID;
  return BASE_SUBCKT::tr_probe_num(n)
;}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::read_probes()
{
  node_t gnd(&ground_node);
  _potential_b_p_n = volts_limited(_n[n_p], _n[n_n]);
  trace2("potential", _potential_b_p_n, _sim->_time0);
}
/*--------------------------------------------------------------------------*/
MOD_resistor::MOD_resistor() :BASE_SUBCKT()
{
  _n = _nodes;
  attach_common(&Default_resistor);
  ++_count;
  // build netlist
  // overrides
}
/*--------------------------------------------------------------------------*/
// seq blocks
/*--------------------------------------------------------------------------*/
bool MOD_resistor::tr_needs_eval()const
{
  node_t gnd(&ground_node);
  if (is_q_for_eval()) { untested();
    return false;
  }else if (!converged()) {
    return true;
  }else if(!conchk(_potential_b_p_n, _n[n_p].v0() - _n[n_n].v0(), 1e-6)){
    return true;
  }else{
    return false;
  }
};
/*--------------------------------------------------------------------------*/
bool MOD_resistor::do_tr()
{
  clear_branch_contributions();
  read_probes();
  COMMON_resistor const* c = prechecked_cast<COMMON_resistor const*>(common());
  assert(c);
  c->tr_eval_analog(this);
  set_branch_contributions();
  assert(subckt());
  set_converged(subckt()->do_tr());
  return converged();
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::set_branch_contributions()
{
  // DEP _potential_b_p_n
  assert(_value_b_p_n == _value_b_p_n);
  _st_b_p_n[0] = _value_b_p_n;
  trace2("_st_b_p_nself", _st_b_p_n[1], _potential_b_p_n);
  _st_b_p_n[0] -= _st_b_p_n[1] * _potential_b_p_n;
  // flow src (p, n)
  // filters
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::clear_branch_contributions()
{
    _value_b_p_n = 0.;
    std::fill_n(_st_b_p_n+1, 1, 0.);
}
/*--------------------------------------------------------------------------*/
inline void COMMON_resistor::tr_eval_analog(MOD_resistor* d) const
{
  MOD_resistor const* p = d;
  assert(p);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    { // 
      ddouble _v_i; // Variable      
      { // Assignment unknown 'i'. Dep: _potential_b_p_n
        ddouble t0;
        t0 = + p->_potential_b_p_n;// V(p, n)
        t0[d_potential_b_p_n] = +1.;
        t0 = t0 / pc->_p_r;
        assert(t0.is_same(t0));
        _v_i = t0.value(); // (*)
        _v_i[d_potential_b_p_n] = t0[d_potential_b_p_n]; // 2
        assert(_v_i == _v_i);
      }
      { // Contribution I
        ddouble t0;
        t0 = _v_i;
        d->_value_b_p_n += t0.value();
        assert(t0[d_potential_b_p_n] == t0[d_potential_b_p_n]);
        d->_st_b_p_n[1] += t0[d_potential_b_p_n];
        // dep _potential_b_p_n
      }
    }
  }
}
  std::string MOD_resistor::port_name(int i)const
{
    assert(i >= 0);
    assert(i < max_nodes());
    static std::string names[] = {"p", "n"    };
    return names[i];
  }
/*--------------------------------------------------------------------------*/
int MOD_resistor::_count = -1;
MOD_resistor m_resistor;
DISPATCHER<CARD>::INSTALL d0(&device_dispatcher, "resistor", &m_resistor);
/*--------------------------------------------------------------------------*/
CARD* MOD_resistor::clone()const
{
  MOD_resistor* new_instance = new MOD_resistor(*this);
  assert(!new_instance->subckt());
  return new_instance;
}
/*--------------------------------------------------------------------------*/
MOD_resistor::MOD_resistor(MOD_resistor const&p) : BASE_SUBCKT(p)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes(); ++ii) {
    _n[ii] = p._n[ii];
    }
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::precalc_first()
{
  BASE_SUBCKT::precalc_first();
  auto c = static_cast<COMMON_resistor*>(mutable_common());
  assert(c);
  if(subckt()){
    subckt()->precalc_first();
  }else{
  }
}
/*--------------------------------------------------------------------------*/
bool MOD_resistor::is_valid()const
{
  COMMON_resistor const* c = prechecked_cast<COMMON_resistor const*>(common());
  return c->is_valid();
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::expand()
{
  BASE_SUBCKT::expand();
  assert(_n);
  assert(common());
  auto c = static_cast</*const*/ COMMON_resistor*>(mutable_common());
  assert(c);
  if (!subckt()) {
    new_subckt();
  }else{
  }

 node_t gnd;
gnd.set_to_ground(this);
  if (_sim->is_first_expand()) {
    precalc_first();
    precalc_last();
      // local nodes

  // clone branches
  // branch (p, n)
    {
    if (!_b_p_n) {
      const CARD* p = device_dispatcher["flow_src"]; // flow_src
      if(!p){
;        throw Exception("Cannot find flow_src. Load module?");
      }else{
      }
      _b_p_n = dynamic_cast<ELEMENT*>(p->clone());
      if(!_b_p_n){
        throw Exception("Cannot use flow_src: wrong type");
      }else{
      }
      subckt()->push_front(_b_p_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_p], _n[n_n]/* self conductance */}; // nodes
        _b_p_n->set_parameters("_b_p_n", this, &_C_V_electrical, 0., /*states:*/2, _st_b_p_n, 2, nodes);
      }
    }

  // clone filters

  }else{
      //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
  subckt()->set_slave();
  for(CARD_LIST::iterator i=subckt()->begin(); i!=subckt()->end(); ++i){
    CARD* d = (*i)->deflate();
    if(d == (*i)){
    }else{
      assert(d->owner() == this);
      delete *i;
      *i = d;
    }
  }
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::precalc_last()
{
  BASE_SUBCKT::precalc_last();
  auto c = static_cast<COMMON_resistor*>(mutable_common());
  assert(c);
  if(subckt()){
    subckt()->precalc_last();
  }else{untested();
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
}
/*--------------------------------------------------------------------------*/
