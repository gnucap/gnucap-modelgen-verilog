/* This file is automatically generated. DO NOT EDIT */
/*--------------------------------------------------------------------------*/
#include <globals.h>
#include <e_compon.h>
#include <e_subckt.h>
#include <e_node.h>
#include <e_elemnt.h>
#include <e_storag.h>
// #include <e_paramlist.h>
#include <u_nodemap.h>
/*                        -*- C++ -*-
 * Copyright (C) 2023 Felix Salfelder
 * Author: Felix Salfelder
 *
 * This file is part of "Gnucap", the Gnu Circuit Analysis Package
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *------------------------------------------------------------------
 */

#ifndef GNUCAP_VA_H
#define GNUCAP_VA_H

#include <md.h>
#include <u_parameter.h>
#include <l_stlextra.h>
#include <e_storag.h>
#include <e_base.h> // CKT_BASE
#include <u_sim_data.h> // see simparam

// attribute index
typedef int aidx;

namespace notstd {
/*--------------------------------------------------------------------------*/
template <class InputIter, class Size, class OutputIter>
void add_n(InputIter first, Size count, OutputIter result)
{
  for ( ; count > 0; --count) {
    *result++ += *first++;
  }
}
/*--------------------------------------------------------------------------*/
}

namespace{

typedef double real;
typedef int integer;
// double inf = std::numeric_limits<double>::infinity();
#define inf std::numeric_limits<double>::infinity()
#define Inf inf

template<int numderiv>
class ddouble_ {
protected:
	double _data[1+numderiv];
public:
	ddouble_(ddouble_ const& o) {
		notstd::copy_n(o._data, numderiv+1, _data);
	}
	explicit ddouble_() { clear(); }
	// fixme: implicit conversion in af args..
	/*explicit*/ ddouble_(int const& d) { clear(); *_data = d; }
	/*explicit*/ ddouble_(double const& d) { clear(); *_data = d; }
	/*explicit*/ ddouble_(PARAMETER<double> const& d) { clear(); *_data = d; }
	void	set_all_deps() {
	  std::fill_n(_data+1, numderiv, 0.);
	}
	void	set_no_deps() {
	  std::fill_n(_data+1, numderiv, std::numeric_limits<double>::quiet_NaN());
	}
private:
	void	reset_deriv(){
	  set_all_deps();
	}
public:
	virtual double const& value()const {return _data[0];}
	double d(int i)const {return _data[i];}
	double const& operator[](int i)const {return _data[i+1];}
	double& operator[](int i){return _data[i+1];}
	operator double()const { return *_data; }
#if 1
 	ddouble_& operator=(ddouble_ const& o) {
 		assert(o == o);
 		notstd::copy_n(o._data, numderiv+1, _data);
 		return *this;
 	}
#else
	ddouble_& operator=(ddouble_ o) {
		assert(o == o);
		notstd::copy_n(o._data, numderiv+1, _data);
		return *this;
	}
#endif
	ddouble_& operator=(PARAMETER<double> const& o) {
		assert(o == o);
		*_data = o;
		reset_deriv();
		return *this;
	}
	ddouble_& operator=(const double& o) {
		assert(o == o);
		*_data = o;
		reset_deriv();
		return *this;
	}
	bool is_same(const ddouble_& o)const {
		for(int i=0; i<=numderiv; ++i){
			if(_data[i] != _data[i]){ itested();
			  if( o._data[i] == o._data[i] ){
				return false;
			  }else{
			  }
			}else if(_data[i] != o._data[i]){ untested();
				return false;
			}else{
			}
		}
		return true;
	}
	bool operator==(const ddouble_& o)const {
#if 0 // really?
		for(int i=0; i<=numderiv; ++i){ untested();
			if(_data[i] != o._data[i]){ untested();
				return false;
			}else{ untested();
			}
		}
#else
		return *_data == *o._data;
#endif
		return true;
	}
	bool operator==(const double& o)const {
		assert(_data);
		return *_data == o;
	}
	bool operator==(const int& o)const {
		double x = o;
		return *_data == x;
	}
	bool operator<(const ddouble_& o)const {
		return *_data < *o._data;
	}
	bool operator<(double const& o)const {
		return *_data < o;
	}
	bool operator<(int const& o)const {
		return *_data < o;
	}
	bool operator<(PARAMETER<double> const& o)const {
		return *_data < double(o);
	}

	bool operator<=(const ddouble_& o)const { itested();
		return *_data <= *o._data;
	}
	bool operator<=(double const& o)const { itested();
		return *_data <= o;
	}
	bool operator<=(int const& o)const { itested();
		return *_data <= o;
	}
	bool operator>(ddouble_ const& o)const {
		return *_data > *o._data;
	}
	bool operator>(double const& o)const {
		return *_data > o;
	}
	bool operator>(int const& o)const {
		return *_data > o;
	}
	bool operator>(PARAMETER<double> const& o)const {
		return *_data > double(o);
	}

	bool operator>=(const ddouble_& o)const { itested();
		return *_data >= *o._data;
	}
	bool operator>=(const double& o)const {itested();
		return *_data >= o;
	}
	bool operator>=(PARAMETER<double> const& o)const {itested();
		return *_data >= double(o);
	}

	ddouble_& operator+=(const ddouble_& o) {
		for(int i=0; i<=numderiv; ++i){
			_data[i] += o._data[i];
		}
		return *this;
	}
	ddouble_ operator+(ddouble_ const& o) const {
		ddouble_ ret = *this;
		ret += o;
		return ret;
	}
	ddouble_ operator+(double const& o) const {
		ddouble_ ret = *this;
		*ret._data += o;
		return ret;
	}
	ddouble_ operator+(int const& o) const {
		ddouble_ ret = *this;
		*ret._data += o;
		return ret;
	}
	ddouble_ operator+(PARAMETER<double> const& o) const {
		ddouble_ ret = *this;
		*ret._data += o;
		return ret;
	}
	ddouble_ operator+()const {
		return ddouble_(*this);
	}

	ddouble_& operator-=(const ddouble_& o) {
		for(int i=0; i<=numderiv; ++i){
			_data[i] -= o._data[i];
		}
		return *this;
	}
	ddouble_ operator-(ddouble_ const& o) const {
		ddouble_ ret = *this;
		ret -= o;
		return ret;
	}
	ddouble_ operator-(double const& o) const {
		ddouble_ ret = *this;
		ret -= ddouble_(o);
		return ret;
	}
	ddouble_ operator-(int const& o) const {
		ddouble_ ret = *this;
		ret -= o;
		return ret;
	}
	ddouble_ operator-(PARAMETER<double> const& o) const {
		ddouble_ ret = *this;
		ret -= double(o);
		return ret;
	}
	ddouble_ operator-() const {
		ddouble_ ret;
		for(int i=0; i<=numderiv; ++i){
			ret._data[i] = - _data[i];
		}
		return ret;
	}

	ddouble_& operator*=(const ddouble_& o) {
		assert(*o._data == *o._data);
		assert(*_data == *_data);
		for(int i=1; i<=numderiv; ++i){
			// assert(_data[i] == _data[i]);
			// assert(o._data[i] == o._data[i]);
			_data[i] *= *o._data;
			_data[i] += *_data * o._data[i];
		}
		*_data *= *o._data;
		return *this;
	}
	ddouble_ operator*(const ddouble_& o) const {
		ddouble_ ret = *this;
		ret *= o;
		return ret;
	}
	ddouble_& operator*=(const double& o) {
		for(int i=0; i<=numderiv; ++i){
			_data[i] *= o;
		}
		return *this;
	}
	ddouble_ operator*(const int& o) const { itested();
		ddouble_ ret = *this;
		ret *= double(o);
		return ret;
	}
	ddouble_ operator*(const double& o) const {itested();
		ddouble_ ret = *this;
		ret *= o;
		return ret;
	}
	ddouble_ operator*(PARAMETER<double> const& o) const {
		ddouble_ ret = *this;
		ret *= (double)o;
		return ret;
	}


	ddouble_& operator/=(ddouble_ const& o) {
		if(*o._data){
			for(int i=1; i<=numderiv; ++i){
				_data[i] *= o.value();
				_data[i] -= value() * o._data[i];
				_data[i] /= o.value() * o.value();
			}
			*_data /= *o._data;
		}else{ itested();
			*this /= (o + 1e-20);
		}
		return *this;
	}
	ddouble_ operator/(ddouble_ o) const {
		ddouble_ ret = *this;
		ret /= o;
		return ret;
	}
	ddouble_& operator/=(double const& o) {
		assert(_data);
		assert(o);
		for(int i=0; i<=numderiv; ++i){
			_data[i] /= o;
		}
		return *this;
	}
//	ddouble_ operator/(double const& o) {
//		assert(o);
//		ddouble_ ret = *this;
//		ret /= o;
//		return ret;
//	}
	ddouble_ operator/(double const& o) const {
		assert(o);
		ddouble_ ret = *this;
		ret /= o;
		return ret;
	}
	ddouble_ operator/(int const& o) const {
		assert(o);
		ddouble_ ret = *this;
		ret /= o;
		return ret;
	}
	ddouble_ operator/(PARAMETER<double> const& o) const {
		assert(o);
		ddouble_ ret = *this;
		ret /= double(o);
		return ret;
	}
	ddouble_ operator/(PARAMETER<int> const& o) const {
		assert(o);
		ddouble_ ret = *this;
		ret /= int(o);
		return ret;
	}
	bool operator!() const { itested();
		assert(_data);
		return *_data == 0.;
	}

	ddouble_& chain(double const& d) {
		for(int i=1; i<=numderiv; ++i){
			_data[i] *= d;
		}
		return *this;
	} /*chain*/
	ddouble_& set_value(double const& v){
		*_data = v;
		return *this;
	}
	void clear() {
		std::fill_n(_data, numderiv+1, 0.);
	} /*clear*/
}; /*ddouble_*/

template<int T>
ddouble_<T> operator/(ddouble_<T> a, ddouble_<T> b)
{
	a /= b;
	return a;
}
template<int T>
ddouble_<T> operator/(int const& a, ddouble_<T> b)
{
	ddouble_<T> c(a);
	c /= b;
	return c;
}
template<int T>
ddouble_<T> operator/(double const& a, ddouble_<T> b)
{
	ddouble_<T> c(a);
	c /= b;
	return c;
}
template<int T>
ddouble_<T> operator/(PARAMETER<double> const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(a);
	c /= b;
	return c;
}
template<int T>
ddouble_<T> operator/(PARAMETER<int> const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(a);
	c /= b;
	return c;
}

template<int T>
ddouble_<T> operator-(double const& a, ddouble_<T> b)
{
	ddouble_<T> c(a);
	c -= b;
	return c;
}
template<int T>
ddouble_<T> operator-(int const& a, ddouble_<T> b)
{ untested();
	ddouble_<T> c(a);
	c -= b;
	return c;
}
template<int T>
ddouble_<T> operator-(PARAMETER<double> const& a, ddouble_<T> b)
{itested();
	ddouble_<T> c(a);
	c -= b;
	return c;
}
template<int T>
ddouble_<T> operator-(PARAMETER<int> const& a, ddouble_<T> b)
{ untested();
	ddouble_<T> c(a);
	c -= b;
	return c;
}

template<int T>
ddouble_<T> operator*(double const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(b);
	c *= a;
	return c;
}
template<int T>
ddouble_<T> operator*(int const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(b);
	c *= a;
	return c;
}
template<int T>
ddouble_<T> operator*(PARAMETER<double> const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(a);
	return c * b;
}
template<int T>
ddouble_<T> operator*(PARAMETER<int> const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(b);
	c *= a;
	return c;
}

template<int T>
ddouble_<T> operator+(double const& a, ddouble_<T> const& b)
{ itested();
	ddouble_<T> c(b);
	return c + a;
}
template<int T>
ddouble_<T> operator+(int const& a, ddouble_<T> const& b)
{ itested();
	ddouble_<T> c(b);
	return c + a;
}
template<int T>
ddouble_<T> operator+(PARAMETER<double> const& a, ddouble_<T> const& b)
{ itested();
	ddouble_<T> c(b);
	return c + a;
}
template<int T>
ddouble_<T> operator+(PARAMETER<int> const& a, ddouble_<T> const& b)
{ untested();
	return b + double(a);
}

template<int T>
bool operator==(ddouble_<T> const& a, PARAMETER<int> const& b)
{ untested();
	return double(b) == a.value();
}
template<int T>
bool operator==(PARAMETER<int> const& b, ddouble_<T> const& a)
{ untested();
	return double(b) == a.value();
}
inline bool operator==(PARAMETER<int> const& b, double const& a)
{ itested();
	return double(b) == a;
}
inline bool operator==(PARAMETER<double> const& b, int const& a)
{ untested();
	return int(b) == a;
}
// inline bool operator==(PARAMETER<int> const& b, int const& a)
// { untested();
// 	return int(b) == a;
// }

template<class T>
T& set_value(T& t, double const& d)
{
	t.set_value(d);
	return t;
}
template<>
inline int& set_value(int& t, double const& v)
{
	return t = int(v);
}
template<>
inline double& set_value(double& t, double const& v)
{
	return t = v;
}
template<>
inline PARAMETER<int>& set_value(PARAMETER<int>& t, double const& v)
{
	t = int(v);
	return t;
}
template<>
inline PARAMETER<double>& set_value(PARAMETER<double>& t, double const& v)
{
	t = v;
	return t;
}

template<class T>
T& chain(T& t, double const& d)
{
	t.chain(d);
	return t;
}
template<>
inline double& chain(double& t, double const&)
{
	// no-op
	return t;
}
template<>
inline int& chain(int& t, double const&)
{
	// no-op
	return t;
}
template<>
inline PARAMETER<double>& chain(PARAMETER<double>& t, double const&)
{ itested();
	// no-op
	return t;
}
template<>
inline PARAMETER<int>& chain(PARAMETER<int>& t, double const&)
{ untested();
	// no-op
	return t;
}


/*--------------------------------------------------------------------------*/
class array_{
  std::vector<double> _v;
public:
  array_() {}
  array_(double a0) {
    _v.push_back(a0);
  }
  array_(double a0, double a1) {
    _v.push_back(a0);
    _v.push_back(a1);
  }
  size_t size() const{return _v.size();}
  double const& operator[](int x)const {return _v[x];}
};
}

/*--------------------------------------------------------------------------*/
namespace va {
// some builtin numerical functions according to verilog standard
// TODO: move to plugins, like the others.
/*--------------------------------------------------------------------------*/
template<class T>
T fmod(T d, T e)
{ untested();
  return std::fmod(d, e);
}
/*--------------------------------------------------------------------------*/
inline double fmod(double d, int e)
{ untested();
  return std::fmod(d, e);
}
/*--------------------------------------------------------------------------*/
inline int fmod(int d, int e)
{ untested();
  return d % e;
}
/*--------------------------------------------------------------------------*/
inline int fmod(PARAMETER<int> const& d, int e)
{itested();
  return d % e;
}
/*--------------------------------------------------------------------------*/
template<class T, class S, class X=void>
struct ddouble_if{
  typedef T type;
};
/*--------------------------------------------------------------------------*/
struct ddouble_tag{};
/*--------------------------------------------------------------------------*/
template<class T, class S>
struct ddouble_if<S, T, typename std::enable_if< std::is_same<typename T::base_tag, ddouble_tag>::value >::type > {
  // typedef typename T::base type;
  typedef T type;
};
/*--------------------------------------------------------------------------*/
template<class T, class S>
struct ddouble_if<T, S, typename T::base> {
  typedef typename T::base type;
};
/*--------------------------------------------------------------------------*/
template<class T, class S>
struct ddouble_if<T, S, typename S::base> {
  typedef typename S::base type;
};
/*--------------------------------------------------------------------------*/
template<class S>
struct ddouble_if<PARAMETER<double>, S> {
  typedef double type;
};
/*--------------------------------------------------------------------------*/
template<>
struct ddouble_if<PARAMETER<double>, double> {
  typedef double type;
};
/*--------------------------------------------------------------------------*/
template<class T, int a>
struct ddouble_if<T, ddouble_<a>>{
  typedef ddouble_<a> type;
};
/*--------------------------------------------------------------------------*/
template<>
struct ddouble_if<double, double>{
  typedef double type;
};
/*--------------------------------------------------------------------------*/
template<class T>
struct ddouble_if<T, double>{
  typedef typename ddouble_if<double, T>::type type;
};
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
template<class S, class T>
typename ddouble_if<T, S>::type max(T d, S e)
{
  typedef typename ddouble_if<T, S>::type ret_t;
  if(double(d) <= double(e)){ itested();
    return ret_t(e);
  }else{itested();
    return ret_t(d);
  }
}
/*--------------------------------------------------------------------------*/
template<class T, class S>
typename ddouble_if<T, S>::type min(T d, S e)
{itested();
  typedef typename ddouble_if<T, S>::type ret_t;
  if(double(d) <= double(e)){itested();
    return ret_t(d);
  }else{ itested();
    return ret_t(e);
  }
}
/*--------------------------------------------------------------------------*/
template<class T, class S=T>
T white_noise(T, S=0.)
{ itested();
  //incomplete();
  return T(0.);
}

template<class T, class T2, class S=T>
T flicker_noise(T, T2, S=0.)
{ itested();
  //incomplete();
  return T(0.);
}
/*--------------------------------------------------------------------------*/
class EVT{
public:
	virtual void operator()() const = 0;
};
/*--------------------------------------------------------------------------*/
} // va
/*--------------------------------------------------------------------------*/
class FILTER {
public:
   virtual double read_filter()const {unreachable(); return 0;}
};
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
#endif
/*--------------------------------------------------------------------------*/
// vim:ts=8:sw=2:noet
/*                        -*- C++ -*-
 * Copyright (C) 2023 Felix Salfelder
 * Author: Felix Salfelder
 *
 * This file is part of "Gnucap", the Gnu Circuit Analysis Package
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *------------------------------------------------------------------
 */

#ifndef GNUCAP_E_VA_H
#define GNUCAP_E_VA_H
/*--------------------------------------------------------------------------*/
#include <e_compon.h>
/*--------------------------------------------------------------------------*/
class NATURE {
public:
  virtual double abstol()const{return 0.;}
};
/*--------------------------------------------------------------------------*/
class DISCIPLINE {
public:
  virtual NATURE const* flow()const {return NULL;}
  virtual NATURE const* potential()const {return NULL;}
};
/*--------------------------------------------------------------------------*/
// tmp kludge. nodes don't have disciplines yet...
class COMMON_VASRC : public COMMON_COMPONENT {
public:
  explicit COMMON_VASRC(int i) : COMMON_COMPONENT(i) {}
  ~COMMON_VASRC() {}
public:
  virtual DISCIPLINE const* discipline()const{return NULL;};
  double flow_abstol() const{
    if(!discipline()){ untested();
      return OPT::abstol;
    }else if(!discipline()->flow()){ untested();
      return OPT::abstol;
    }else{
      return discipline()->flow()->abstol();
    }
  }
  double potential_abstol() const{
    if(!discipline()){ untested();
      return OPT::abstol;
    }else if(!discipline()->potential()){
      return OPT::abstol;
    }else{
      return discipline()->potential()->abstol();
    }
  }
};
/*--------------------------------------------------------------------------*/
class COMMON_FILT : public COMMON_COMPONENT {
public:
  explicit COMMON_FILT(int i=CC_STATIC) : COMMON_COMPONENT(i) {}
  ~COMMON_FILT() {}
public:
  //virtual DISCIPLINE const* discipline()const{untested(); return NULL;};
  virtual int args(int) const{ return 0; }
};
/*--------------------------------------------------------------------------*/
inline void e_val(double* p, const double& x, const CARD_LIST*)
{
  assert(p);
  *p = x;
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
#endif
// vim:ts=8:sw=2:noet:
#include <u_limit.h>
/*--------------------------------------------------------------------------*/
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic ignored "-Wshadow"
const double NA(NOT_INPUT);
const double INF(BIGBIG);
/*--------------------------------------------------------------------------*/
namespace {
/*--------------------------------------------------------------------------*/
class NATURE_current : public NATURE {
  double abstol()const override {return 1e-12;}
}_N_current;
class NATURE_voltage : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_voltage;
class NATURE_power : public NATURE {
  double abstol()const override {return 0.00101010;}
}_N_power;
class NATURE_flux : public NATURE {
  double abstol()const override {return 1e-5;}
}_N_flux;
class NATURE_temperature : public NATURE {
  double abstol()const override {return 3.14;}
}_N_temperature;
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
class DISCIPLINE_thermal : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_power;
  }
  NATURE const* potential()const override{
    return &_N_temperature;
  }
}_D_thermal;
class _COMMON_VASRC_thermal : public COMMON_VASRC {
public:
  _COMMON_VASRC_thermal(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_thermal(_COMMON_VASRC_thermal const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_thermal(*this);
  }
  std::string name()const override{untested(); return "thermal";}
  DISCIPLINE const* discipline()const override {return &_D_thermal;}
public:
};
static _COMMON_VASRC_thermal _C_V_thermal(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_electrical : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_current;
  }
  NATURE const* potential()const override{
    return &_N_voltage;
  }
}_D_electrical;
class _COMMON_VASRC_electrical : public COMMON_VASRC {
public:
  _COMMON_VASRC_electrical(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_electrical(_COMMON_VASRC_electrical const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_electrical(*this);
  }
  std::string name()const override{untested(); return "electrical";}
  DISCIPLINE const* discipline()const override {return &_D_electrical;}
public:
};
static _COMMON_VASRC_electrical _C_V_electrical(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_magnetic : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_current;
  }
  NATURE const* potential()const override{
    return &_N_voltage;
  }
}_D_magnetic;
class _COMMON_VASRC_magnetic : public COMMON_VASRC {
public:
  _COMMON_VASRC_magnetic(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_magnetic(_COMMON_VASRC_magnetic const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_magnetic(*this);
  }
  std::string name()const override{untested(); return "magnetic";}
  DISCIPLINE const* discipline()const override {return &_D_magnetic;}
public:
};
static _COMMON_VASRC_magnetic _C_V_magnetic(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_rotational_omega : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_current;
  }
  NATURE const* potential()const override{
    return &_N_voltage;
  }
}_D_rotational_omega;
class _COMMON_VASRC_rotational_omega : public COMMON_VASRC {
public:
  _COMMON_VASRC_rotational_omega(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_rotational_omega(_COMMON_VASRC_rotational_omega const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_rotational_omega(*this);
  }
  std::string name()const override{untested(); return "rotational_omega";}
  DISCIPLINE const* discipline()const override {return &_D_rotational_omega;}
public:
};
static _COMMON_VASRC_rotational_omega _C_V_rotational_omega(CC_STATIC);
/*--------------------------------------------------------------------------*/
namespace n0{
class MOD_resistor;
class COMMON_resistor :public COMMON_COMPONENT{
  typedef MOD_resistor MOD;
  typedef ddouble_<1> ddouble;
  enum {
    d_potential_b_p_n,
// not named: _b_p_n
     num_branches__  };
public:
  explicit COMMON_resistor(const COMMON_resistor& p);
  explicit COMMON_resistor(int c=0);
           ~COMMON_resistor();
  bool     operator==(const COMMON_COMPONENT&)const override;
  COMMON_COMPONENT* clone()const override {return new COMMON_resistor(*this);}
  void     set_param_by_index(int, std::string&, int)override;
  aidx     set_param_by_name(std::string, std::string)override;
  bool     is_valid()const;
  bool     param_is_printable(int)const override;
  std::string param_name(int)const override;
  std::string param_name(int,int)const override;
  std::string param_value(int)const override;
  int param_count()const override {return (1 + COMMON_COMPONENT::param_count());}
  void precalc_first(const CARD_LIST*)override;
  void expand(const COMPONENT*)override;
  void precalc_last(const CARD_LIST*)override;
  void tr_eval_analog(MOD_resistor*)const;
  void precalc_analog(MOD_resistor*)const;
  std::string name()const override {itested();return "resistor";}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<real> _p_r /*  */;
private: // funcs
// Probe no refs: potential_p_n
}; //COMMON_resistor
/*--------------------------------------------------------------------------*/
class PRECALC_resistor{
  MOD_resistor* _d{NULL};
public:
  typedef ddouble_<1> ddouble;
  enum {
    d_potential_b_p_n,
// not named: _b_p_n
     num_branches__  };
public:
  explicit PRECALC_resistor(MOD_resistor*d) : _d(d) {}
};
/*--------------------------------------------------------------------------*/
class MOD_resistor : public BASE_SUBCKT {
private:
  static int _count;
public:
  typedef ddouble_<1> ddouble;
  enum {
    d_potential_b_p_n,
// not named: _b_p_n
     num_branches__  };
private: // data
  node_t _nodes[2];
public: // netlist
  ELEMENT* _b_p_n{NULL}; // branch
private: // func decl
//probe potential_p_n
  ddouble xs_potential_b_p_n() const { // potential_p_n
    ddouble t;
    t = _potential_b_p_n; // unnamed
    t[d_potential_b_p_n] = 1; // unnamed
    return t;
  }
private: // construct
  explicit MOD_resistor(MOD_resistor const&);
public:
  explicit MOD_resistor(); // : BASE_SUBCKT() { _n = _nodes; }
  CARD* clone()const override;
private: // overrides
  bool is_valid()const override;
  void precalc_first()override;
  void expand()override;
  void precalc_last()override;
  void zero_filter_readout();
  //void    map_nodes();         //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
  void    tr_load()override{ trace1("tr_load", long_label());BASE_SUBCKT::tr_load();}
  //TIME_PAIR  tr_review()override;         //BASE_SUBCKT
  //void    tr_accept()override;         //BASE_SUBCKT
  //void    tr_unload();         //BASE_SUBCKT
  void      dc_advance()override {set_not_converged(); BASE_SUBCKT::dc_advance();}
  void      tr_advance()override;
  void      tr_regress()override {set_not_converged(); BASE_SUBCKT::tr_regress();}
  bool      tr_needs_eval()const override;
  void      tr_queue_eval()override {if(tr_needs_eval()){q_eval();}else{} }
  bool      do_tr() override;
  double tr_probe_num(std::string const&)const override;
    //void    ac_load();           //BASE_SUBCKT
    //XPROBE  ac_probe_ext(CS&)const;//CKT_BASE/nothing
  int max_nodes()const override {return 2;}
  int min_nodes()const override {return 2;}
  int int_nodes()const override    {return 0;}
  std::string value_name()const override {itested(); return "";}
  bool print_type_in_spice()const override {itested(); return false;}
  std::string port_name(int i)const override;
private: // impl
/* ========== */
public: // instance vars
  double  _v_i{0.};
private: // branch state
public: // states, _b_p_n;
  double _value_b_p_n;
  double _st_b_p_n  [2]; // (s)
  struct _st_b_p_n_ {
    enum {     VALUE, SELF/* : */
    };
  } _dep_b_p_n;
private: // node list
  enum {
    n_p /* used: 1 */,
    n_n /* used: 1 */
  };
private: // probe values
  double _potential_b_p_n;
private: // impl
  void read_probes();
  void set_branch_contributions();
  void clear_branch_contributions();
  friend class COMMON_resistor;
  friend class PRECALC_resistor;
}; // m_resistor;
/*--------------------------------------------------------------------------*/
COMMON_resistor::COMMON_resistor(int c)
  :COMMON_COMPONENT(c),
   _p_r(/*default*/)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_resistor::COMMON_resistor(const COMMON_resistor& p)
  :COMMON_COMPONENT(p),
   _p_r(p._p_r)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_resistor::~COMMON_resistor()
{
  --_count;
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_resistor* p = dynamic_cast<const COMMON_resistor*>(&x);
  return (p
    && _p_r == p->_p_r
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_resistor::param_count() - 1 - I) {
  case 0:  _p_r = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
aidx COMMON_resistor::set_param_by_name(std::string Name, std::string Value)
{
  if(Name == "$mfactor"){ Name = "m"; }
  static std::string names[] = {"r"  };
  int lb = 0;
  int ub = 1;
  while(lb < ub) {
    int mid = (lb+ub)/2;
    int c = std::strcmp(Name.c_str(), names[mid].c_str());
    if(c<0){
      ub = mid;
    }else if(c>0){
      lb = mid+1;
    }else{
      lb = mid;
      ub = 1;
      assert(lb<ub);
      break;
    }
  }
  assert(lb<=ub);
  switch(ub-lb){
    case 1:_p_r = Value;    break; // 0
    case 0: return COMMON_COMPONENT::set_param_by_name(Name, Value); break;
  }
  return lb;
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::param_is_printable(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return (_p_r.has_hard_value());
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_name(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return "r";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_name(int i, int j)const
{
  if(j==0){
    return param_name(i);
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_value(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return _p_r.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::is_valid() const
{
  COMMON_resistor const* pc = this;
  (void)pc;
  {
  double lb, ub;
  {
  ddouble t0;
  t0 =  10.E-9;
  lb = t0;
  }
  {
  ddouble t0;
  t0 =  Inf;
  ub = t0;
  }
  if(!(lb<=_p_r && _p_r<ub)){ return false; }else{ }
  }
  return true; //COMMON_COMPONENT::is_valid();
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_r),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_r),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int COMMON_resistor::_count = -1;
static COMMON_resistor Default_resistor(CC_STATIC);
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
double MOD_resistor::tr_probe_num(std::string const& n) const
{
  //i:i
  if(n == "i"){
    return _v_i;
  }
  if(n == "conv") {
    return converged();
  }
  return BASE_SUBCKT::tr_probe_num(n);
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::read_probes()
{
  trace0("resistor::read_probes");
  node_t gnd(&ground_node);
  _potential_b_p_n = volts_limited(_n[n_p], _n[n_n]);
}
/*--------------------------------------------------------------------------*/
MOD_resistor::MOD_resistor()
    :BASE_SUBCKT()
{
  _n = _nodes;
  attach_common(&Default_resistor);
  ++_count;
  // build netlist
  // ports:2
  // overrides
}
/*--------------------------------------------------------------------------*/
// seq blocks
/*--------------------------------------------------------------------------*/
bool MOD_resistor::tr_needs_eval()const
{
  trace2("resistor::needs_eval?", long_label(), has_probes());
  node_t gnd(&ground_node);
  if (is_q_for_eval()) { untested();
    return false;
  }else if (!converged()) {
    return true;
  }else if (has_probes()) {
    return true;
  }else  if( !conchk(_potential_b_p_n, _n[n_p].v0() - _n[n_n].v0(), 1e-6)){
    return true;
  }else{
    return false;
  }
};
/*--------------------------------------------------------------------------*/
#if 0
// tr_eval_branch _b_p_n
static EVAL__b_p_n_ Eval_(p, n)(CC_STATIC);
void EVAL__b_p_n_::tr_eval(ELEMENT* d)const
{
  assert(d);
  auto* p = prechecked_cast<DEV_resistor*>(d->owner());
  assert(p);
  const COMMON_resistor* c = prechecked_cast<const COMMON_resistor*>(p->common());
  assert(c);
  {
    { // 
// omit Assignment..
      { // Contribution I(p, n) lin: 1
        ddouble t0;
        // t0[d_potential_b_p_n] = 0.; // (output dep)
        t0 = _v_i/*rhsvar*/;
        d->_value_b_p_n /* contrib sign: */ += t0.value();
        assert(t0[d_potential_b_p_n] == t0[d_potential_b_p_n]);
        d->_st_b_p_n[1] += t0[d_potential_b_p_n];
        // dep _potential_b_p_n
        // same _potential_b_p_n
      }
    }
  }
}
/*--------------------------------------------------------------------------*/
#endif
bool MOD_resistor::do_tr()
{
  trace3("resistor::do_tr", this, long_label(), _sim->iteration_number());
  clear_branch_contributions();
  read_probes();
  COMMON_resistor const* c = prechecked_cast<COMMON_resistor const*>(common());
  assert(c);
  set_converged();
  c->tr_eval_analog(this);
  set_branch_contributions();
  assert(subckt());
  set_converged(subckt()->do_tr() && converged());
  return converged();
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::zero_filter_readout()
{
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::set_branch_contributions()
{
    { // 1
    assert(_value_b_p_n == _value_b_p_n);
    _st_b_p_n[0] = _value_b_p_n;
    // same _potential_b_p_n
    trace2("_st_b_p_nself", _st_b_p_n[1], _potential_b_p_n);
    // generic: 0
    // self
    _st_b_p_n[0] -= _st_b_p_n[1] * _potential_b_p_n; // (4)
    // sources...
      { // set state 
      long double sp = 0.;
      // _potential_b_p_n lin: 1
      _st_b_p_n[0] = double(_st_b_p_n[0] - sp);
      }
    }
  // flow src (p, n)
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::clear_branch_contributions()
{
    _value_b_p_n = 0.;
    std::fill_n(_st_b_p_n+1, 1, 0.);
}
/*--------------------------------------------------------------------------*/
typedef MOD_resistor::ddouble ddouble;
inline void COMMON_resistor::tr_eval_analog(MOD_resistor* d) const
{
  trace1("resistor::tr_eval_analog", d);
  trace1("resistor::tr_eval_analog", d->long_label());
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
  class _V_i : public ddouble {
    MOD_resistor * const _m;
  public:
    typedef ddouble base;
    typedef va::ddouble_tag base_tag;
    _V_i(ddouble const& p) : ddouble(p), _m(NULL) { itested(); }
    _V_i(double const& p) : ddouble(p), _m(NULL) {set_all_deps();}
    _V_i(PARAMETER<double> const& p) : ddouble(p), _m(NULL) {set_all_deps();}
    _V_i(_V_i const& p) : ddouble(p), _m(NULL) {}
    explicit _V_i() : ddouble(), _m(NULL) {set_all_deps();}
    _V_i(MOD_resistor * m) : ddouble(m->_v_i), _m(m) {}
    ~_V_i() {
	if(_m){
      _m->_v_i = value();
    }else{itested(); }}
    ddouble& operator=(double t){
      ddouble::operator=(t);
      return *this;
    }
    ddouble& operator=(ddouble t){
      ddouble::operator=(t);
      return *this;
    }
  }_v_i(d);
#pragma GCC diagnostic pop
  MOD_resistor const* p = d;
  assert(p);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    { // 
      { // Assignment real 'i'.
        ddouble t0;
        // t0[d_potential_b_p_n] = 0.; // (output dep)
        t0.set_no_deps();
        t0 = p->xs_potential_b_p_n();
        t0 = t0 / (_p_r) /*rhspar*/;
        _v_i = t0.value(); // (*)
        _v_i[d_potential_b_p_n] = t0[d_potential_b_p_n]; // (2b)
        assert(_v_i[d_potential_b_p_n] == t0[d_potential_b_p_n]); // (2b2)
      }
      { // Contribution I(p, n) lin: 1
        ddouble t0;
        // t0[d_potential_b_p_n] = 0.; // (output dep)
        t0 = _v_i/*rhsvar*/;
        d->_value_b_p_n /* contrib sign: */ += t0.value();
        assert(t0[d_potential_b_p_n] == t0[d_potential_b_p_n]);
        d->_st_b_p_n[1] += t0[d_potential_b_p_n];
        // dep _potential_b_p_n
        // same _potential_b_p_n
      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline void COMMON_resistor::precalc_analog(MOD_resistor* m) const
{
  MOD_resistor const* p = m;
  assert(p);
  (void)p;
  COMMON_resistor const* pc = this;
  (void)pc;
  PRECALC_resistor P(m);
  PRECALC_resistor* d = &P;
  (void)d;
  ddouble _v_i(m->_v_i);
  (void) _v_i;
  {
    { // 
      { // Assignment real 'i'.
        ddouble t0;
        t0 = 0.; // static?
        t0 = t0 / (_p_r) /*rhspar*/;
        _v_i = t0; // (prec)
      }
      { // Contribution I(p, n) lin: 1
        ddouble t0;
        t0 = _v_i/*rhsvar*/;
        // same _potential_b_p_n
      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::tr_advance()
{
  set_not_converged();
  return BASE_SUBCKT::tr_advance();
}
/*--------------------------------------------------------------------------*/
  std::string MOD_resistor::port_name(int i)const
{
    assert(i >= 0);
    assert(i < max_nodes());
    static std::string names[] = {"p", "n"    };
    return names[i];
  }
/*--------------------------------------------------------------------------*/
int MOD_resistor::_count = -1;
MOD_resistor m_resistor;
DISPATCHER<CARD>::INSTALL d0(&device_dispatcher, "resistor", &m_resistor);
/*--------------------------------------------------------------------------*/
CARD* MOD_resistor::clone()const
{
  MOD_resistor* new_instance = new MOD_resistor(*this);
  assert(!new_instance->subckt());
  return new_instance;
}
/*--------------------------------------------------------------------------*/
MOD_resistor::MOD_resistor(MOD_resistor const&p) : BASE_SUBCKT(p)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes(); ++ii) {
    _n[ii] = p._n[ii];
    }
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::precalc_first()
{
  BASE_SUBCKT::precalc_first();
  trace2("resistor::pf", long_label(), mfactor());
  auto c = static_cast<COMMON_resistor*>(mutable_common());
  assert(c);
  auto cc = c->clone();
  if(subckt()){
    attach_common(NULL);
    attach_common(cc);
    subckt()->precalc_first();
  }else{
  }
}
/*--------------------------------------------------------------------------*/
bool MOD_resistor::is_valid()const
{
  COMMON_resistor const* c = prechecked_cast<COMMON_resistor const*>(common());
  return c->is_valid();
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::expand()
{
  trace1("expand", long_label());
  BASE_SUBCKT::expand();
  assert(_n);
  assert(common());
  auto c = static_cast</*const*/ COMMON_resistor*>(mutable_common());
  assert(c);
  (void)c;
  if (!subckt()) {
    new_subckt();
  }else{
  }

  node_t gnd;
  gnd.set_to_ground(this);
  // port p 1
  // port n 2
  if (_sim->is_first_expand()) {
    precalc_first();

  // clone branches
  // branch (p, n)
    {
    if (!_b_p_n) {
      const CARD* p = device_dispatcher["va_flow"]; // va_flow
      if(!p){
        throw Exception("Cannot find va_flow. Load module?");
      }else{
      }
      _b_p_n = dynamic_cast<ELEMENT*>(p->clone()); // elt
      if(!_b_p_n){
        throw Exception("Cannot use va_flow: wrong type");
      }else{
      }
      subckt()->push_front(_b_p_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_p], _n[n_n]}; // nodes
        _b_p_n->set_parameters("_b_p_n", this, &_C_V_electrical, 0., /*states:*/2, _st_b_p_n, 2, nodes);
      }
    }

  // clone filters

  }else{
      //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
  for(CARD_LIST::iterator i=subckt()->begin(); i!=subckt()->end(); ++i){
    CARD* d = (*i)->deflate();
    if(d == (*i)){
    }else{
      assert(d->owner() == this);
      delete *i;
      *i = d;
    }
  }
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::precalc_last()
{
  BASE_SUBCKT::precalc_last();
  auto c = static_cast<COMMON_resistor*>(mutable_common());
  assert(c);
  (void)c;
  zero_filter_readout();
  c->precalc_analog(this);
  if(subckt()){
    subckt()->precalc_last();
  }else{untested();
  }
}
/*--------------------------------------------------------------------------*/
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
}
/*--------------------------------------------------------------------------*/
/* This file is automatically generated. DO NOT EDIT */
/*--------------------------------------------------------------------------*/
#include <globals.h>
#include <e_compon.h>
#include <e_subckt.h>
#include <e_node.h>
#include <e_elemnt.h>
#include <e_storag.h>
// #include <e_paramlist.h>
#include <u_nodemap.h>
/*                        -*- C++ -*-
 * Copyright (C) 2023 Felix Salfelder
 * Author: Felix Salfelder
 *
 * This file is part of "Gnucap", the Gnu Circuit Analysis Package
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *------------------------------------------------------------------
 */

#ifndef GNUCAP_VA_H
#define GNUCAP_VA_H

#include <md.h>
#include <u_parameter.h>
#include <l_stlextra.h>
#include <e_storag.h>
#include <e_base.h> // CKT_BASE
#include <u_sim_data.h> // see simparam

// attribute index
typedef int aidx;

namespace notstd {
/*--------------------------------------------------------------------------*/
template <class InputIter, class Size, class OutputIter>
void add_n(InputIter first, Size count, OutputIter result)
{
  for ( ; count > 0; --count) {
    *result++ += *first++;
  }
}
/*--------------------------------------------------------------------------*/
}

namespace{

typedef double real;
typedef int integer;
// double inf = std::numeric_limits<double>::infinity();
#define inf std::numeric_limits<double>::infinity()
#define Inf inf

template<int numderiv>
class ddouble_ {
protected:
	double _data[1+numderiv];
public:
	ddouble_(ddouble_ const& o) {
		notstd::copy_n(o._data, numderiv+1, _data);
	}
	explicit ddouble_() { clear(); }
	// fixme: implicit conversion in af args..
	/*explicit*/ ddouble_(int const& d) { clear(); *_data = d; }
	/*explicit*/ ddouble_(double const& d) { clear(); *_data = d; }
	/*explicit*/ ddouble_(PARAMETER<double> const& d) { clear(); *_data = d; }
	void	set_all_deps() {
	  std::fill_n(_data+1, numderiv, 0.);
	}
	void	set_no_deps() {
	  std::fill_n(_data+1, numderiv, std::numeric_limits<double>::quiet_NaN());
	}
private:
	void	reset_deriv(){
	  set_all_deps();
	}
public:
	virtual double const& value()const {return _data[0];}
	double d(int i)const {return _data[i];}
	double const& operator[](int i)const {return _data[i+1];}
	double& operator[](int i){return _data[i+1];}
	operator double()const { return *_data; }
#if 1
 	ddouble_& operator=(ddouble_ const& o) {
 		assert(o == o);
 		notstd::copy_n(o._data, numderiv+1, _data);
 		return *this;
 	}
#else
	ddouble_& operator=(ddouble_ o) {
		assert(o == o);
		notstd::copy_n(o._data, numderiv+1, _data);
		return *this;
	}
#endif
	ddouble_& operator=(PARAMETER<double> const& o) {
		assert(o == o);
		*_data = o;
		reset_deriv();
		return *this;
	}
	ddouble_& operator=(const double& o) {
		assert(o == o);
		*_data = o;
		reset_deriv();
		return *this;
	}
	bool is_same(const ddouble_& o)const {
		for(int i=0; i<=numderiv; ++i){
			if(_data[i] != _data[i]){ itested();
			  if( o._data[i] == o._data[i] ){
				return false;
			  }else{
			  }
			}else if(_data[i] != o._data[i]){ untested();
				return false;
			}else{
			}
		}
		return true;
	}
	bool operator==(const ddouble_& o)const {
#if 0 // really?
		for(int i=0; i<=numderiv; ++i){ untested();
			if(_data[i] != o._data[i]){ untested();
				return false;
			}else{ untested();
			}
		}
#else
		return *_data == *o._data;
#endif
		return true;
	}
	bool operator==(const double& o)const {
		assert(_data);
		return *_data == o;
	}
	bool operator==(const int& o)const {
		double x = o;
		return *_data == x;
	}
	bool operator<(const ddouble_& o)const {
		return *_data < *o._data;
	}
	bool operator<(double const& o)const {
		return *_data < o;
	}
	bool operator<(int const& o)const {
		return *_data < o;
	}
	bool operator<(PARAMETER<double> const& o)const {
		return *_data < double(o);
	}

	bool operator<=(const ddouble_& o)const { itested();
		return *_data <= *o._data;
	}
	bool operator<=(double const& o)const { itested();
		return *_data <= o;
	}
	bool operator<=(int const& o)const { itested();
		return *_data <= o;
	}
	bool operator>(ddouble_ const& o)const {
		return *_data > *o._data;
	}
	bool operator>(double const& o)const {
		return *_data > o;
	}
	bool operator>(int const& o)const {
		return *_data > o;
	}
	bool operator>(PARAMETER<double> const& o)const {
		return *_data > double(o);
	}

	bool operator>=(const ddouble_& o)const { itested();
		return *_data >= *o._data;
	}
	bool operator>=(const double& o)const {itested();
		return *_data >= o;
	}
	bool operator>=(PARAMETER<double> const& o)const {itested();
		return *_data >= double(o);
	}

	ddouble_& operator+=(const ddouble_& o) {
		for(int i=0; i<=numderiv; ++i){
			_data[i] += o._data[i];
		}
		return *this;
	}
	ddouble_ operator+(ddouble_ const& o) const {
		ddouble_ ret = *this;
		ret += o;
		return ret;
	}
	ddouble_ operator+(double const& o) const {
		ddouble_ ret = *this;
		*ret._data += o;
		return ret;
	}
	ddouble_ operator+(int const& o) const {
		ddouble_ ret = *this;
		*ret._data += o;
		return ret;
	}
	ddouble_ operator+(PARAMETER<double> const& o) const {
		ddouble_ ret = *this;
		*ret._data += o;
		return ret;
	}
	ddouble_ operator+()const {
		return ddouble_(*this);
	}

	ddouble_& operator-=(const ddouble_& o) {
		for(int i=0; i<=numderiv; ++i){
			_data[i] -= o._data[i];
		}
		return *this;
	}
	ddouble_ operator-(ddouble_ const& o) const {
		ddouble_ ret = *this;
		ret -= o;
		return ret;
	}
	ddouble_ operator-(double const& o) const {
		ddouble_ ret = *this;
		ret -= ddouble_(o);
		return ret;
	}
	ddouble_ operator-(int const& o) const {
		ddouble_ ret = *this;
		ret -= o;
		return ret;
	}
	ddouble_ operator-(PARAMETER<double> const& o) const {
		ddouble_ ret = *this;
		ret -= double(o);
		return ret;
	}
	ddouble_ operator-() const {
		ddouble_ ret;
		for(int i=0; i<=numderiv; ++i){
			ret._data[i] = - _data[i];
		}
		return ret;
	}

	ddouble_& operator*=(const ddouble_& o) {
		assert(*o._data == *o._data);
		assert(*_data == *_data);
		for(int i=1; i<=numderiv; ++i){
			// assert(_data[i] == _data[i]);
			// assert(o._data[i] == o._data[i]);
			_data[i] *= *o._data;
			_data[i] += *_data * o._data[i];
		}
		*_data *= *o._data;
		return *this;
	}
	ddouble_ operator*(const ddouble_& o) const {
		ddouble_ ret = *this;
		ret *= o;
		return ret;
	}
	ddouble_& operator*=(const double& o) {
		for(int i=0; i<=numderiv; ++i){
			_data[i] *= o;
		}
		return *this;
	}
	ddouble_ operator*(const int& o) const { itested();
		ddouble_ ret = *this;
		ret *= double(o);
		return ret;
	}
	ddouble_ operator*(const double& o) const {itested();
		ddouble_ ret = *this;
		ret *= o;
		return ret;
	}
	ddouble_ operator*(PARAMETER<double> const& o) const {
		ddouble_ ret = *this;
		ret *= (double)o;
		return ret;
	}


	ddouble_& operator/=(ddouble_ const& o) {
		if(*o._data){
			for(int i=1; i<=numderiv; ++i){
				_data[i] *= o.value();
				_data[i] -= value() * o._data[i];
				_data[i] /= o.value() * o.value();
			}
			*_data /= *o._data;
		}else{ itested();
			*this /= (o + 1e-20);
		}
		return *this;
	}
	ddouble_ operator/(ddouble_ o) const {
		ddouble_ ret = *this;
		ret /= o;
		return ret;
	}
	ddouble_& operator/=(double const& o) {
		assert(_data);
		assert(o);
		for(int i=0; i<=numderiv; ++i){
			_data[i] /= o;
		}
		return *this;
	}
//	ddouble_ operator/(double const& o) {
//		assert(o);
//		ddouble_ ret = *this;
//		ret /= o;
//		return ret;
//	}
	ddouble_ operator/(double const& o) const {
		assert(o);
		ddouble_ ret = *this;
		ret /= o;
		return ret;
	}
	ddouble_ operator/(int const& o) const {
		assert(o);
		ddouble_ ret = *this;
		ret /= o;
		return ret;
	}
	ddouble_ operator/(PARAMETER<double> const& o) const {
		assert(o);
		ddouble_ ret = *this;
		ret /= double(o);
		return ret;
	}
	ddouble_ operator/(PARAMETER<int> const& o) const {
		assert(o);
		ddouble_ ret = *this;
		ret /= int(o);
		return ret;
	}
	bool operator!() const { itested();
		assert(_data);
		return *_data == 0.;
	}

	ddouble_& chain(double const& d) {
		for(int i=1; i<=numderiv; ++i){
			_data[i] *= d;
		}
		return *this;
	} /*chain*/
	ddouble_& set_value(double const& v){
		*_data = v;
		return *this;
	}
	void clear() {
		std::fill_n(_data, numderiv+1, 0.);
	} /*clear*/
}; /*ddouble_*/

template<int T>
ddouble_<T> operator/(ddouble_<T> a, ddouble_<T> b)
{
	a /= b;
	return a;
}
template<int T>
ddouble_<T> operator/(int const& a, ddouble_<T> b)
{
	ddouble_<T> c(a);
	c /= b;
	return c;
}
template<int T>
ddouble_<T> operator/(double const& a, ddouble_<T> b)
{
	ddouble_<T> c(a);
	c /= b;
	return c;
}
template<int T>
ddouble_<T> operator/(PARAMETER<double> const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(a);
	c /= b;
	return c;
}
template<int T>
ddouble_<T> operator/(PARAMETER<int> const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(a);
	c /= b;
	return c;
}

template<int T>
ddouble_<T> operator-(double const& a, ddouble_<T> b)
{
	ddouble_<T> c(a);
	c -= b;
	return c;
}
template<int T>
ddouble_<T> operator-(int const& a, ddouble_<T> b)
{ untested();
	ddouble_<T> c(a);
	c -= b;
	return c;
}
template<int T>
ddouble_<T> operator-(PARAMETER<double> const& a, ddouble_<T> b)
{itested();
	ddouble_<T> c(a);
	c -= b;
	return c;
}
template<int T>
ddouble_<T> operator-(PARAMETER<int> const& a, ddouble_<T> b)
{ untested();
	ddouble_<T> c(a);
	c -= b;
	return c;
}

template<int T>
ddouble_<T> operator*(double const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(b);
	c *= a;
	return c;
}
template<int T>
ddouble_<T> operator*(int const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(b);
	c *= a;
	return c;
}
template<int T>
ddouble_<T> operator*(PARAMETER<double> const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(a);
	return c * b;
}
template<int T>
ddouble_<T> operator*(PARAMETER<int> const& a, ddouble_<T> const& b)
{
	ddouble_<T> c(b);
	c *= a;
	return c;
}

template<int T>
ddouble_<T> operator+(double const& a, ddouble_<T> const& b)
{ itested();
	ddouble_<T> c(b);
	return c + a;
}
template<int T>
ddouble_<T> operator+(int const& a, ddouble_<T> const& b)
{ itested();
	ddouble_<T> c(b);
	return c + a;
}
template<int T>
ddouble_<T> operator+(PARAMETER<double> const& a, ddouble_<T> const& b)
{ itested();
	ddouble_<T> c(b);
	return c + a;
}
template<int T>
ddouble_<T> operator+(PARAMETER<int> const& a, ddouble_<T> const& b)
{ untested();
	return b + double(a);
}

template<int T>
bool operator==(ddouble_<T> const& a, PARAMETER<int> const& b)
{ untested();
	return double(b) == a.value();
}
template<int T>
bool operator==(PARAMETER<int> const& b, ddouble_<T> const& a)
{ untested();
	return double(b) == a.value();
}
inline bool operator==(PARAMETER<int> const& b, double const& a)
{ itested();
	return double(b) == a;
}
inline bool operator==(PARAMETER<double> const& b, int const& a)
{ untested();
	return int(b) == a;
}
// inline bool operator==(PARAMETER<int> const& b, int const& a)
// { untested();
// 	return int(b) == a;
// }

template<class T>
T& set_value(T& t, double const& d)
{
	t.set_value(d);
	return t;
}
template<>
inline int& set_value(int& t, double const& v)
{
	return t = int(v);
}
template<>
inline double& set_value(double& t, double const& v)
{
	return t = v;
}
template<>
inline PARAMETER<int>& set_value(PARAMETER<int>& t, double const& v)
{
	t = int(v);
	return t;
}
template<>
inline PARAMETER<double>& set_value(PARAMETER<double>& t, double const& v)
{
	t = v;
	return t;
}

template<class T>
T& chain(T& t, double const& d)
{
	t.chain(d);
	return t;
}
template<>
inline double& chain(double& t, double const&)
{
	// no-op
	return t;
}
template<>
inline int& chain(int& t, double const&)
{
	// no-op
	return t;
}
template<>
inline PARAMETER<double>& chain(PARAMETER<double>& t, double const&)
{ itested();
	// no-op
	return t;
}
template<>
inline PARAMETER<int>& chain(PARAMETER<int>& t, double const&)
{ untested();
	// no-op
	return t;
}


/*--------------------------------------------------------------------------*/
class array_{
  std::vector<double> _v;
public:
  array_() {}
  array_(double a0) {
    _v.push_back(a0);
  }
  array_(double a0, double a1) {
    _v.push_back(a0);
    _v.push_back(a1);
  }
  size_t size() const{return _v.size();}
  double const& operator[](int x)const {return _v[x];}
};
}

/*--------------------------------------------------------------------------*/
namespace va {
// some builtin numerical functions according to verilog standard
// TODO: move to plugins, like the others.
/*--------------------------------------------------------------------------*/
template<class T>
T fmod(T d, T e)
{ untested();
  return std::fmod(d, e);
}
/*--------------------------------------------------------------------------*/
inline double fmod(double d, int e)
{ untested();
  return std::fmod(d, e);
}
/*--------------------------------------------------------------------------*/
inline int fmod(int d, int e)
{ untested();
  return d % e;
}
/*--------------------------------------------------------------------------*/
inline int fmod(PARAMETER<int> const& d, int e)
{itested();
  return d % e;
}
/*--------------------------------------------------------------------------*/
template<class T, class S, class X=void>
struct ddouble_if{
  typedef T type;
};
/*--------------------------------------------------------------------------*/
struct ddouble_tag{};
/*--------------------------------------------------------------------------*/
template<class T, class S>
struct ddouble_if<S, T, typename std::enable_if< std::is_same<typename T::base_tag, ddouble_tag>::value >::type > {
  // typedef typename T::base type;
  typedef T type;
};
/*--------------------------------------------------------------------------*/
template<class T, class S>
struct ddouble_if<T, S, typename T::base> {
  typedef typename T::base type;
};
/*--------------------------------------------------------------------------*/
template<class T, class S>
struct ddouble_if<T, S, typename S::base> {
  typedef typename S::base type;
};
/*--------------------------------------------------------------------------*/
template<class S>
struct ddouble_if<PARAMETER<double>, S> {
  typedef double type;
};
/*--------------------------------------------------------------------------*/
template<>
struct ddouble_if<PARAMETER<double>, double> {
  typedef double type;
};
/*--------------------------------------------------------------------------*/
template<class T, int a>
struct ddouble_if<T, ddouble_<a>>{
  typedef ddouble_<a> type;
};
/*--------------------------------------------------------------------------*/
template<>
struct ddouble_if<double, double>{
  typedef double type;
};
/*--------------------------------------------------------------------------*/
template<class T>
struct ddouble_if<T, double>{
  typedef typename ddouble_if<double, T>::type type;
};
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
template<class S, class T>
typename ddouble_if<T, S>::type max(T d, S e)
{
  typedef typename ddouble_if<T, S>::type ret_t;
  if(double(d) <= double(e)){ itested();
    return ret_t(e);
  }else{itested();
    return ret_t(d);
  }
}
/*--------------------------------------------------------------------------*/
template<class T, class S>
typename ddouble_if<T, S>::type min(T d, S e)
{itested();
  typedef typename ddouble_if<T, S>::type ret_t;
  if(double(d) <= double(e)){itested();
    return ret_t(d);
  }else{ itested();
    return ret_t(e);
  }
}
/*--------------------------------------------------------------------------*/
template<class T, class S=T>
T white_noise(T, S=0.)
{ itested();
  //incomplete();
  return T(0.);
}

template<class T, class T2, class S=T>
T flicker_noise(T, T2, S=0.)
{ itested();
  //incomplete();
  return T(0.);
}
/*--------------------------------------------------------------------------*/
class EVT{
public:
	virtual void operator()() const = 0;
};
/*--------------------------------------------------------------------------*/
} // va
/*--------------------------------------------------------------------------*/
class FILTER {
public:
   virtual double read_filter()const {unreachable(); return 0;}
};
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
#endif
/*--------------------------------------------------------------------------*/
// vim:ts=8:sw=2:noet
/*                        -*- C++ -*-
 * Copyright (C) 2023 Felix Salfelder
 * Author: Felix Salfelder
 *
 * This file is part of "Gnucap", the Gnu Circuit Analysis Package
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *------------------------------------------------------------------
 */

#ifndef GNUCAP_E_VA_H
#define GNUCAP_E_VA_H
/*--------------------------------------------------------------------------*/
#include <e_compon.h>
/*--------------------------------------------------------------------------*/
class NATURE {
public:
  virtual double abstol()const{return 0.;}
};
/*--------------------------------------------------------------------------*/
class DISCIPLINE {
public:
  virtual NATURE const* flow()const {return NULL;}
  virtual NATURE const* potential()const {return NULL;}
};
/*--------------------------------------------------------------------------*/
// tmp kludge. nodes don't have disciplines yet...
class COMMON_VASRC : public COMMON_COMPONENT {
public:
  explicit COMMON_VASRC(int i) : COMMON_COMPONENT(i) {}
  ~COMMON_VASRC() {}
public:
  virtual DISCIPLINE const* discipline()const{return NULL;};
  double flow_abstol() const{
    if(!discipline()){ untested();
      return OPT::abstol;
    }else if(!discipline()->flow()){ untested();
      return OPT::abstol;
    }else{
      return discipline()->flow()->abstol();
    }
  }
  double potential_abstol() const{
    if(!discipline()){ untested();
      return OPT::abstol;
    }else if(!discipline()->potential()){
      return OPT::abstol;
    }else{
      return discipline()->potential()->abstol();
    }
  }
};
/*--------------------------------------------------------------------------*/
class COMMON_FILT : public COMMON_COMPONENT {
public:
  explicit COMMON_FILT(int i=CC_STATIC) : COMMON_COMPONENT(i) {}
  ~COMMON_FILT() {}
public:
  //virtual DISCIPLINE const* discipline()const{untested(); return NULL;};
  virtual int args(int) const{ return 0; }
};
/*--------------------------------------------------------------------------*/
inline void e_val(double* p, const double& x, const CARD_LIST*)
{
  assert(p);
  *p = x;
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
#endif
// vim:ts=8:sw=2:noet:
#include <u_limit.h>
/*--------------------------------------------------------------------------*/
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic ignored "-Wshadow"
const double NA(NOT_INPUT);
const double INF(BIGBIG);
/*--------------------------------------------------------------------------*/
namespace {
/*--------------------------------------------------------------------------*/
class NATURE_current : public NATURE {
  double abstol()const override {return 1e-12;}
}_N_current;
class NATURE_voltage : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_voltage;
class NATURE_power : public NATURE {
  double abstol()const override {return 0.00101010;}
}_N_power;
class NATURE_flux : public NATURE {
  double abstol()const override {return 1e-5;}
}_N_flux;
class NATURE_temperature : public NATURE {
  double abstol()const override {return 3.14;}
}_N_temperature;
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
class DISCIPLINE_thermal : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_power;
  }
  NATURE const* potential()const override{
    return &_N_temperature;
  }
}_D_thermal;
class _COMMON_VASRC_thermal : public COMMON_VASRC {
public:
  _COMMON_VASRC_thermal(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_thermal(_COMMON_VASRC_thermal const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_thermal(*this);
  }
  std::string name()const override{untested(); return "thermal";}
  DISCIPLINE const* discipline()const override {return &_D_thermal;}
public:
};
static _COMMON_VASRC_thermal _C_V_thermal(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_electrical : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_current;
  }
  NATURE const* potential()const override{
    return &_N_voltage;
  }
}_D_electrical;
class _COMMON_VASRC_electrical : public COMMON_VASRC {
public:
  _COMMON_VASRC_electrical(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_electrical(_COMMON_VASRC_electrical const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_electrical(*this);
  }
  std::string name()const override{untested(); return "electrical";}
  DISCIPLINE const* discipline()const override {return &_D_electrical;}
public:
};
static _COMMON_VASRC_electrical _C_V_electrical(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_magnetic : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_current;
  }
  NATURE const* potential()const override{
    return &_N_voltage;
  }
}_D_magnetic;
class _COMMON_VASRC_magnetic : public COMMON_VASRC {
public:
  _COMMON_VASRC_magnetic(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_magnetic(_COMMON_VASRC_magnetic const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_magnetic(*this);
  }
  std::string name()const override{untested(); return "magnetic";}
  DISCIPLINE const* discipline()const override {return &_D_magnetic;}
public:
};
static _COMMON_VASRC_magnetic _C_V_magnetic(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_rotational_omega : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_current;
  }
  NATURE const* potential()const override{
    return &_N_voltage;
  }
}_D_rotational_omega;
class _COMMON_VASRC_rotational_omega : public COMMON_VASRC {
public:
  _COMMON_VASRC_rotational_omega(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_rotational_omega(_COMMON_VASRC_rotational_omega const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_rotational_omega(*this);
  }
  std::string name()const override{untested(); return "rotational_omega";}
  DISCIPLINE const* discipline()const override {return &_D_rotational_omega;}
public:
};
static _COMMON_VASRC_rotational_omega _C_V_rotational_omega(CC_STATIC);
/*--------------------------------------------------------------------------*/
namespace n0{
class MOD_capacitor;
class COMMON_capacitor :public COMMON_COMPONENT{
  typedef MOD_capacitor MOD;
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_1_p_ddt_1_n,
    d_potential_b_p_n,
// not named: _b_ddt_1_p_ddt_1_n
// not named: _b_p_n
     num_branches__  };
public:
  explicit COMMON_capacitor(const COMMON_capacitor& p);
  explicit COMMON_capacitor(int c=0);
           ~COMMON_capacitor();
  bool     operator==(const COMMON_COMPONENT&)const override;
  COMMON_COMPONENT* clone()const override {return new COMMON_capacitor(*this);}
  void     set_param_by_index(int, std::string&, int)override;
  aidx     set_param_by_name(std::string, std::string)override;
  bool     is_valid()const;
  bool     param_is_printable(int)const override;
  std::string param_name(int)const override;
  std::string param_name(int,int)const override;
  std::string param_value(int)const override;
  int param_count()const override {return (1 + COMMON_COMPONENT::param_count());}
  void precalc_first(const CARD_LIST*)override;
  void expand(const COMPONENT*)override;
  void precalc_last(const CARD_LIST*)override;
  void tr_eval_analog(MOD_capacitor*)const;
  void precalc_analog(MOD_capacitor*)const;
  std::string name()const override {itested();return "capacitor";}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<real> _p_c /*  */;
  real _p___c /*  */;
  real _p___ic /*  */;
private: // funcs
  bool param_given(PARA_BASE const& p)const {
    return p.has_hard_value();
  }
  double _f_analysis(std::string const& what)const {
    if(what=="ic"){
      return _sim->analysis_is_tran_static();
    }else if(what=="static"){
      return _sim->analysis_is_static();
    }else if(what=="dc"){
      return _sim->analysis_is_dcop();
    }else if(what=="noise"){ itested();
      return false; // later
    }else{ untested();
      incomplete();
      return false;
    }
  }
// Probe no refs: potential_ddt_1_p_
// Probe no refs: potential_p_n
}; //COMMON_capacitor
/*--------------------------------------------------------------------------*/
class PRECALC_capacitor{
  MOD_capacitor* _d{NULL};
public:
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_1_p_ddt_1_n,
    d_potential_b_p_n,
// not named: _b_ddt_1_p_ddt_1_n
// not named: _b_p_n
     num_branches__  };
public:
  explicit PRECALC_capacitor(MOD_capacitor*d) : _d(d) {}
  ddouble _b_ddt_1(ddouble){
  ddouble ret = 0.;
  ret[d_potential_b_ddt_1_p_ddt_1_n] = -1.;
  return ret;
}
};
/*--------------------------------------------------------------------------*/
class MOD_capacitor : public BASE_SUBCKT {
private:
  static int _count;
public:
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_1_p_ddt_1_n,
    d_potential_b_p_n,
// not named: _b_ddt_1_p_ddt_1_n
// not named: _b_p_n
     num_branches__  };
private: // data
  node_t _nodes[4];
public: // netlist
  ELEMENT* _b_ddt_1_p_ddt_1_n{NULL}; // filter
  ELEMENT* _b_p_n{NULL}; // branch
private: // func decl
//other: $param_given
//other: analysis
//filt ddt_1
  ddouble _b_ddt_1(ddouble t0);
  bool _short_b_ddt_1()const {return 1;}
//probe potential_ddt_1_p_
  ddouble xs_potential_b_ddt_1_p_ddt_1_n() const { // potential_ddt_1_p_
    ddouble t;
    t = _potential_b_ddt_1_p_ddt_1_n; // unnamed
    t[d_potential_b_ddt_1_p_ddt_1_n] = 1; // unnamed
    return t;
  }
//probe potential_p_n
  ddouble xs_potential_b_p_n() const { // potential_p_n
    ddouble t;
    t = _potential_b_p_n; // unnamed
    t[d_potential_b_p_n] = 1; // unnamed
    return t;
  }
private: // construct
  explicit MOD_capacitor(MOD_capacitor const&);
public:
  explicit MOD_capacitor(); // : BASE_SUBCKT() { _n = _nodes; }
  CARD* clone()const override;
private: // overrides
  bool is_valid()const override;
  void precalc_first()override;
  void expand()override;
  void precalc_last()override;
  void zero_filter_readout();
  //void    map_nodes();         //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
  void    tr_load()override{ trace1("tr_load", long_label());BASE_SUBCKT::tr_load();}
  TIME_PAIR  tr_review()override;
  void    tr_accept()override;
  //void    tr_unload();         //BASE_SUBCKT
  void      dc_advance()override {set_not_converged(); BASE_SUBCKT::dc_advance();}
  void      tr_advance()override;
  void      tr_regress()override {set_not_converged(); BASE_SUBCKT::tr_regress();}
  bool      tr_needs_eval()const override;
  void      tr_queue_eval()override {if(tr_needs_eval()){q_eval();}else{} }
  bool      do_tr() override;
  double tr_probe_num(std::string const&)const override;
    //void    ac_load();           //BASE_SUBCKT
    //XPROBE  ac_probe_ext(CS&)const;//CKT_BASE/nothing
  int max_nodes()const override {return 2;}
  int min_nodes()const override {return 2;}
  int int_nodes()const override    {return 2;}
  std::string value_name()const override {itested(); return "";}
  bool print_type_in_spice()const override {itested(); return false;}
  std::string port_name(int i)const override;
private: // impl
/* ========== */
public: // instance vars
private: // branch state
public: // states, _b_ddt_1_p_ddt_1_n;
  double _value_b_ddt_1_p_ddt_1_n;
  double _st_b_ddt_1_p_ddt_1_n  [3]; // (s)
  struct _st_b_ddt_1_p_ddt_1_n_ {
    enum {     VALUE, SELF, dep_potential_b_p_n/* : */
    };
  } _dep_b_ddt_1_p_ddt_1_n;
public: // states, _b_p_n;
  double _value_b_p_n;
  double _st_b_p_n  [3]; // (s)
  struct _st_b_p_n_ {
    enum {     VALUE, SELF, dep_potential_b_ddt_1_p_ddt_1_n/* : */
    };
  } _dep_b_p_n;
private: // node list
  enum {
    n_p /* used: 1 */,
    n_n /* used: 1 */
    /* ---- */,
    n_ddt_1_p /* used: 1 */,
    n_ddt_1_n /* used: 0 */
  };
private: // probe values
  double _potential_b_ddt_1_p_ddt_1_n;
  double _potential_b_p_n;
private: // impl
  void read_probes();
  void set_branch_contributions();
  void clear_branch_contributions();
  friend class COMMON_capacitor;
  friend class PRECALC_capacitor;
}; // m_capacitor;
/*--------------------------------------------------------------------------*/
COMMON_capacitor::COMMON_capacitor(int c)
  :COMMON_COMPONENT(c),
   _p_c(/*default*/),
   _p___c(/*default*/),
   _p___ic(/*default*/)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_capacitor::COMMON_capacitor(const COMMON_capacitor& p)
  :COMMON_COMPONENT(p),
   _p_c(p._p_c)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_capacitor::~COMMON_capacitor()
{
  --_count;
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_capacitor* p = dynamic_cast<const COMMON_capacitor*>(&x);
  return (p
    && _p_c == p->_p_c
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_capacitor::param_count() - 1 - I) {
  case 0:  _p_c = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
aidx COMMON_capacitor::set_param_by_name(std::string Name, std::string Value)
{
  if(Name == "$mfactor"){ Name = "m"; }
  static std::string names[] = {"c"  };
  int lb = 0;
  int ub = 1;
  while(lb < ub) {
    int mid = (lb+ub)/2;
    int c = std::strcmp(Name.c_str(), names[mid].c_str());
    if(c<0){
      ub = mid;
    }else if(c>0){
      lb = mid+1;
    }else{
      lb = mid;
      ub = 1;
      assert(lb<ub);
      break;
    }
  }
  assert(lb<=ub);
  switch(ub-lb){
    case 1:_p_c = Value;    break; // 0
    case 0: return COMMON_COMPONENT::set_param_by_name(Name, Value); break;
  }
  return lb;
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::param_is_printable(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return (_p_c.has_hard_value());
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_name(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return "c";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_name(int i, int j)const
{
  if(j==0){
    return param_name(i);
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_value(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return _p_c.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::is_valid() const
{
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
  double lb, ub;
  {
  ddouble t0;
  t0 =  0.;
  lb = t0;
  }
  {
  ddouble t0;
  t0 =  Inf;
  ub = t0;
  }
  if(!(lb<=_p_c && _p_c<ub)){ return false; }else{ }
  }
  return true; //COMMON_COMPONENT::is_valid();
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_c),     def , par_scope);
  }
  {
    ddouble t0;
    t0 = (_p_c) /*rhspar*/;
    real def = real(t0.value());
    this->_p___c = def;
  }
  {
    ddouble t0;
    t0 =  0.;
    real def = real(t0.value());
    this->_p___ic = def;
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_c),     def , par_scope);
  }
  {
    ddouble t0;
    t0 = (_p_c) /*rhspar*/;
    real def = real(t0.value());
    this->_p___c = def;
  }
  {
    ddouble t0;
    t0 =  0.;
    real def = real(t0.value());
    this->_p___ic = def;
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int COMMON_capacitor::_count = -1;
static COMMON_capacitor Default_capacitor(CC_STATIC);
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
double MOD_capacitor::tr_probe_num(std::string const& n) const
{
  if(n == "conv") {
    return converged();
  }
  return BASE_SUBCKT::tr_probe_num(n);
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::read_probes()
{
  trace0("capacitor::read_probes");
  node_t gnd(&ground_node);
  // filter _b_ddt_1_p_ddt_1_n
  _potential_b_p_n = volts_limited(_n[n_p], _n[n_n]);
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::MOD_capacitor()
    :BASE_SUBCKT()
{
  _n = _nodes;
  attach_common(&Default_capacitor);
  ++_count;
  // build netlist
  // ports:2
  // overrides
}
/*--------------------------------------------------------------------------*/
// seq blocks
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::tr_needs_eval()const
{
  trace2("capacitor::needs_eval?", long_label(), has_probes());
  node_t gnd(&ground_node);
  if (is_q_for_eval()) { untested();
    return false;
  }else if (!converged()) {
    return true;
  }else if (has_probes()) {
    return true;
  }else   if(_sim->is_first_iteration()){
    return true;
  }else if( !conchk(_potential_b_p_n, _n[n_p].v0() - _n[n_n].v0(), 1e-6)){
    return true;
  }else{
    return false;
  }
};
/*--------------------------------------------------------------------------*/
#if 0
// tr_eval_branch _b_ddt_1_p_ddt_1_n
static EVAL__b_ddt_1_p_ddt_1_n_ Eval_(ddt_1_p, )(CC_STATIC);
void EVAL__b_ddt_1_p_ddt_1_n_::tr_eval(ELEMENT* d)const
{
  assert(d);
  auto* p = prechecked_cast<DEV_capacitor*>(d->owner());
  assert(p);
  const COMMON_capacitor* c = prechecked_cast<const COMMON_capacitor*>(p->common());
  assert(c);
  {
    { // 
// omit statement
    }
  }
}
/*--------------------------------------------------------------------------*/
// tr_eval_branch _b_p_n
static EVAL__b_p_n_ Eval_(p, n)(CC_STATIC);
void EVAL__b_p_n_::tr_eval(ELEMENT* d)const
{
  assert(d);
  auto* p = prechecked_cast<DEV_capacitor*>(d->owner());
  assert(p);
  const COMMON_capacitor* c = prechecked_cast<const COMMON_capacitor*>(p->common());
  assert(c);
  {
    { // 
// omit statement
    }
  }
}
/*--------------------------------------------------------------------------*/
#endif
bool MOD_capacitor::do_tr()
{
  trace3("capacitor::do_tr", this, long_label(), _sim->iteration_number());
  clear_branch_contributions();
  read_probes();
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  assert(c);
  set_converged();
  c->tr_eval_analog(this);
  set_branch_contributions();
  assert(subckt());
  set_converged(subckt()->do_tr() && converged());
  return converged();
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::zero_filter_readout()
{
  _potential_b_ddt_1_p_ddt_1_n = 0.;
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::set_branch_contributions()
{
    { // 1
    assert(_value_b_p_n == _value_b_p_n);
    _st_b_p_n[0] = _value_b_p_n;
    // sources...
      { // set state 
      long double sp = 0.;
      // _potential_b_ddt_1_p_ddt_1_n lin: 1
      sp += (long double)(_st_b_p_n[_st_b_p_n_::dep_potential_b_ddt_1_p_ddt_1_n] * _potential_b_ddt_1_p_ddt_1_n);
      _st_b_p_n[0] = double(_st_b_p_n[0] - sp);
      }
    }
  // flow src (p, n)
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::clear_branch_contributions()
{
    _value_b_p_n = 0.;
    std::fill_n(_st_b_p_n+1, 2, 0.);
}
/*--------------------------------------------------------------------------*/
typedef MOD_capacitor::ddouble ddouble;
inline void COMMON_capacitor::tr_eval_analog(MOD_capacitor* d) const
{
  trace1("capacitor::tr_eval_analog", d);
  trace1("capacitor::tr_eval_analog", d->long_label());
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic pop
  MOD_capacitor const* p = d;
  assert(p);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    { // 
      {
        { // 
          { // Contribution I(p, n) lin: 1
            ddouble t0;
            // t0[d_potential_b_ddt_1_p_ddt_1_n] = 0.; // (output dep)
            t0.set_no_deps();
            t0 = p->xs_potential_b_p_n();
            t0 = (_p___c) /*rhspar*/ * t0;
            // function ddt 1
            t0 =  /*(312)*/ /*call1*//*XDT*/ d->_b_ddt_1(t0);
            d->_value_b_p_n /* contrib sign: */ += t0.value();
            // dep _potential_b_ddt_1_p_ddt_1_n
            assert(t0[d_potential_b_ddt_1_p_ddt_1_n] == t0[d_potential_b_ddt_1_p_ddt_1_n]);
            d->_st_b_p_n[MOD::_st_b_p_n_::dep_potential_b_ddt_1_p_ddt_1_n] += t0[d_potential_b_ddt_1_p_ddt_1_n]; // (3)
          }
        }
      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline void COMMON_capacitor::precalc_analog(MOD_capacitor* m) const
{
  MOD_capacitor const* p = m;
  assert(p);
  (void)p;
  COMMON_capacitor const* pc = this;
  (void)pc;
  PRECALC_capacitor P(m);
  PRECALC_capacitor* d = &P;
  (void)d;
  {
    { // 
      {
        { // 
          { // Contribution I(p, n) lin: 1
            ddouble t0;
            t0 = 0.; // static?
            t0 = (_p___c) /*rhspar*/ * t0;
            // function ddt 1
            t0 =  /*(312)*/ /*call1*//*XDT*/ d->_b_ddt_1(t0);
            // dep _potential_b_ddt_1_p_ddt_1_n
            m->_st_b_ddt_1_p_ddt_1_n[1] = - t0[d_potential_b_ddt_1_p_ddt_1_n]; // (3p)
          }
        }
      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline TIME_PAIR MOD_capacitor::tr_review()
{
  {itested();
  }
  TIME_PAIR time_by = BASE_SUBCKT::tr_review();
  return time_by;
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::tr_accept()
{
  return BASE_SUBCKT::tr_accept();
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::tr_advance()
{
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  assert(c);
  if(_sim->_last_time == 0.){
  c->tr_eval_analog(this);
  }else{
  }
  set_not_converged();
  return BASE_SUBCKT::tr_advance();
}
/*--------------------------------------------------------------------------*/
  std::string MOD_capacitor::port_name(int i)const
{
    assert(i >= 0);
    assert(i < max_nodes());
    static std::string names[] = {"p", "n"    };
    return names[i];
  }
/*--------------------------------------------------------------------------*/
int MOD_capacitor::_count = -1;
MOD_capacitor m_capacitor;
DISPATCHER<CARD>::INSTALL d0(&device_dispatcher, "capacitor", &m_capacitor);
/*--------------------------------------------------------------------------*/
CARD* MOD_capacitor::clone()const
{
  MOD_capacitor* new_instance = new MOD_capacitor(*this);
  assert(!new_instance->subckt());
  return new_instance;
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::MOD_capacitor(MOD_capacitor const&p) : BASE_SUBCKT(p)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes(); ++ii) {
    _n[ii] = p._n[ii];
    }
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::precalc_first()
{
  BASE_SUBCKT::precalc_first();
  trace2("capacitor::pf", long_label(), mfactor());
  auto c = static_cast<COMMON_capacitor*>(mutable_common());
  assert(c);
  auto cc = c->clone();
  if(subckt()){
    attach_common(NULL);
    attach_common(cc);
    subckt()->precalc_first();
  }else{
  }
}
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::is_valid()const
{
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  return c->is_valid();
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::expand()
{
  trace1("expand", long_label());
  BASE_SUBCKT::expand();
  assert(_n);
  assert(common());
  auto c = static_cast</*const*/ COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  if (!subckt()) {
    new_subckt();
  }else{
  }

  node_t gnd;
  gnd.set_to_ground(this);
  // port p 1
  // port n 2
  // internal ddt_1_p : 3
  // node ddt_1_p 3
    //assert(!(_n[n_ddt_1_p].n_()));
    //BUG// this assert fails on a repeat elaboration after a change.
    //not sure of consequences when new_model_node called twice.
    if (!(_n[n_ddt_1_p].n_())) {
    if (_short_b_ddt_1()) {
      _n[n_ddt_1_p] = gnd;
    }else{
      _n[n_ddt_1_p].new_model_node("." + long_label() + ".ddt_1_p", this);
      }
    }else{
    {
       //_n[n_ddt_1_p].new_model_node("ddt_1_p." + long_label(), this);
    }
  }
  // ground
  _n[n_ddt_1_n].set_to_ground(this);
  if (_sim->is_first_expand()) {
    precalc_first();

  // clone branches
  // filter (ddt_1_p, )
    {
    if (!_b_ddt_1_p_ddt_1_n) {
      const CARD* p = device_dispatcher["va_ddt"]; // va_ddt
      if(!p){
        throw Exception("Cannot find va_ddt. Load module?");
      }else{
      }
      _b_ddt_1_p_ddt_1_n = dynamic_cast<ELEMENT*>(p->clone()); // elt
      if(!_b_ddt_1_p_ddt_1_n){
        throw Exception("Cannot use va_ddt: wrong type");
      }else{
      }
      subckt()->push_front(_b_ddt_1_p_ddt_1_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_p], _n[n_n], _n[n_p], _n[n_n]}; // nodes
        _b_ddt_1_p_ddt_1_n->set_parameters("_b_ddt_1_p_ddt_1_n", this, _b_ddt_1_p_ddt_1_n->mutable_common(), 0., /*states:*/3, _st_b_ddt_1_p_ddt_1_n, 4, nodes);
        if(auto e = dynamic_cast<ELEMENT*>(_b_ddt_1_p_ddt_1_n)){
          e->_loss0 = 0.;
          e->_loss1 = 0.;
        }else{
        }
      }
    }
  // branch (p, n)
    {
    if (!_b_p_n) {
      const CARD* p = device_dispatcher["va_flow"]; // va_flow
      if(!p){
        throw Exception("Cannot find va_flow. Load module?");
      }else{
      }
      _b_p_n = dynamic_cast<ELEMENT*>(p->clone()); // elt
      if(!_b_p_n){
        throw Exception("Cannot use va_flow: wrong type");
      }else{
      }
      subckt()->push_front(_b_p_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_p], _n[n_n], _n[n_ddt_1_p], gnd}; // nodes
        _b_p_n->set_parameters("_b_p_n", this, &_C_V_electrical, 0., /*states:*/3, _st_b_p_n, 4, nodes);
      }
    }

  // clone filters

  }else{
      //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
  for(CARD_LIST::iterator i=subckt()->begin(); i!=subckt()->end(); ++i){
    CARD* d = (*i)->deflate();
    if(d == (*i)){
    }else{
      assert(d->owner() == this);
      delete *i;
      *i = d;
    }
  }
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::precalc_last()
{
  BASE_SUBCKT::precalc_last();
  auto c = static_cast<COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  zero_filter_readout();
  c->precalc_analog(this);
  if(subckt()){
    subckt()->precalc_last();
  }else{untested();
  }
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::ddouble MOD_capacitor::_b_ddt_1(ddouble t0)
{
  MOD_capacitor* d = this;
  typedef MOD_capacitor MOD;
    d->_st_b_ddt_1_p_ddt_1_n[0] = + t0.value();
    // dep _potential_b_p_n
    assert(t0[d_potential_b_p_n] == t0[d_potential_b_p_n]);
    // assert(!d->_st_b_ddt_1_p_ddt_1_n[2]);
    d->_st_b_ddt_1_p_ddt_1_n[MOD::_st_b_ddt_1_p_ddt_1_n_::dep_potential_b_p_n]  = + t0[d_potential_b_p_n]; // (4)
  // subdevice
  t0 = 0.;
  t0[d_potential_b_ddt_1_p_ddt_1_n] = 1.;
  assert(t0 == t0);
  return t0; // (output)
}
/*--------------------------------------------------------------------------*/
}
namespace n1{
class MOD_capacitor;
class COMMON_capacitor :public COMMON_COMPONENT{
  typedef MOD_capacitor MOD;
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_2_p_ddt_2_n,
    d_potential_b_p_n,
// not named: _b_ddt_2_p_ddt_2_n
// not named: _b_p_n
     num_branches__  };
public:
  explicit COMMON_capacitor(const COMMON_capacitor& p);
  explicit COMMON_capacitor(int c=0);
           ~COMMON_capacitor();
  bool     operator==(const COMMON_COMPONENT&)const override;
  COMMON_COMPONENT* clone()const override {return new COMMON_capacitor(*this);}
  void     set_param_by_index(int, std::string&, int)override;
  aidx     set_param_by_name(std::string, std::string)override;
  bool     is_valid()const;
  bool     param_is_printable(int)const override;
  std::string param_name(int)const override;
  std::string param_name(int,int)const override;
  std::string param_value(int)const override;
  int param_count()const override {return (2 + COMMON_COMPONENT::param_count());}
  void precalc_first(const CARD_LIST*)override;
  void expand(const COMPONENT*)override;
  void precalc_last(const CARD_LIST*)override;
  void tr_eval_analog(MOD_capacitor*)const;
  void precalc_analog(MOD_capacitor*)const;
  std::string name()const override {itested();return "capacitor";}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<real> _p_c /*  */;
  PARAMETER<real> _p_ic /*  */;
  real _p___c /*  */, _p___ic /*  */;
private: // funcs
  bool param_given(PARA_BASE const& p)const {
    return p.has_hard_value();
  }
  double _f_analysis(std::string const& what)const {
    if(what=="ic"){
      return _sim->analysis_is_tran_static();
    }else if(what=="static"){
      return _sim->analysis_is_static();
    }else if(what=="dc"){
      return _sim->analysis_is_dcop();
    }else if(what=="noise"){ itested();
      return false; // later
    }else{ untested();
      incomplete();
      return false;
    }
  }
// Probe no refs: potential_ddt_2_p_
// Probe no refs: potential_p_n
}; //COMMON_capacitor
/*--------------------------------------------------------------------------*/
class PRECALC_capacitor{
  MOD_capacitor* _d{NULL};
public:
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_2_p_ddt_2_n,
    d_potential_b_p_n,
// not named: _b_ddt_2_p_ddt_2_n
// not named: _b_p_n
     num_branches__  };
public:
  explicit PRECALC_capacitor(MOD_capacitor*d) : _d(d) {}
  ddouble _b_ddt_2(ddouble){
  ddouble ret = 0.;
  ret[d_potential_b_ddt_2_p_ddt_2_n] = -1.;
  return ret;
}
};
/*--------------------------------------------------------------------------*/
class MOD_capacitor : public BASE_SUBCKT {
private:
  static int _count;
public:
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_2_p_ddt_2_n,
    d_potential_b_p_n,
// not named: _b_ddt_2_p_ddt_2_n
// not named: _b_p_n
     num_branches__  };
private: // data
  node_t _nodes[4];
public: // netlist
  ELEMENT* _b_ddt_2_p_ddt_2_n{NULL}; // filter
  ELEMENT* _b_p_n{NULL}; // branch
private: // func decl
//other: $param_given
//other: analysis
//filt ddt_2
  ddouble _b_ddt_2(ddouble t0);
  bool _short_b_ddt_2()const {return 0;}
//probe potential_ddt_2_p_
  ddouble xs_potential_b_ddt_2_p_ddt_2_n() const { // potential_ddt_2_p_
    ddouble t;
    t = _potential_b_ddt_2_p_ddt_2_n; // unnamed
    t[d_potential_b_ddt_2_p_ddt_2_n] = 1; // unnamed
    return t;
  }
//probe potential_p_n
  ddouble xs_potential_b_p_n() const { // potential_p_n
    ddouble t;
    t = _potential_b_p_n; // unnamed
    t[d_potential_b_p_n] = 1; // unnamed
    return t;
  }
private: // construct
  explicit MOD_capacitor(MOD_capacitor const&);
public:
  explicit MOD_capacitor(); // : BASE_SUBCKT() { _n = _nodes; }
  CARD* clone()const override;
private: // overrides
  bool is_valid()const override;
  void precalc_first()override;
  void expand()override;
  void precalc_last()override;
  void zero_filter_readout();
  //void    map_nodes();         //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
  void    tr_load()override{ trace1("tr_load", long_label());BASE_SUBCKT::tr_load();}
  TIME_PAIR  tr_review()override;
  void    tr_accept()override;
  //void    tr_unload();         //BASE_SUBCKT
  void      dc_advance()override {set_not_converged(); BASE_SUBCKT::dc_advance();}
  void      tr_advance()override;
  void      tr_regress()override {set_not_converged(); BASE_SUBCKT::tr_regress();}
  bool      tr_needs_eval()const override;
  void      tr_queue_eval()override {if(tr_needs_eval()){q_eval();}else{} }
  bool      do_tr() override;
  double tr_probe_num(std::string const&)const override;
    //void    ac_load();           //BASE_SUBCKT
    //XPROBE  ac_probe_ext(CS&)const;//CKT_BASE/nothing
  int max_nodes()const override {return 2;}
  int min_nodes()const override {return 2;}
  int int_nodes()const override    {return 2;}
  std::string value_name()const override {itested(); return "";}
  bool print_type_in_spice()const override {itested(); return false;}
  std::string port_name(int i)const override;
private: // impl
/* ========== */
public: // instance vars
private: // branch state
public: // states, _b_ddt_2_p_ddt_2_n;
  double _value_b_ddt_2_p_ddt_2_n;
  double _st_b_ddt_2_p_ddt_2_n  [3]; // (s)
  struct _st_b_ddt_2_p_ddt_2_n_ {
    enum {     VALUE, SELF, dep_potential_b_p_n/* : */
    };
  } _dep_b_ddt_2_p_ddt_2_n;
public: // states, _b_p_n;
  bool _pot_b_p_n;
  double _value_b_p_n;
  double _st_b_p_n  [3]; // (s)
  struct _st_b_p_n_ {
    enum {     VALUE, SELF, dep_potential_b_ddt_2_p_ddt_2_n/* : */
    };
  } _dep_b_p_n;
private: // node list
  enum {
    n_p /* used: 1 */,
    n_n /* used: 1 */
    /* ---- */,
    n_ddt_2_p /* used: 1 */,
    n_ddt_2_n /* used: 0 */
  };
private: // probe values
  double _potential_b_ddt_2_p_ddt_2_n;
  double _potential_b_p_n;
private: // impl
  void read_probes();
  void set_branch_contributions();
  void clear_branch_contributions();
  friend class COMMON_capacitor;
  friend class PRECALC_capacitor;
}; // m_capacitor;
/*--------------------------------------------------------------------------*/
COMMON_capacitor::COMMON_capacitor(int c)
  :COMMON_COMPONENT(c),
   _p_c(/*default*/),
   _p_ic(/*default*/),
   _p___c(/*default*/),
   _p___ic(/*default*/)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_capacitor::COMMON_capacitor(const COMMON_capacitor& p)
  :COMMON_COMPONENT(p),
   _p_c(p._p_c),
   _p_ic(p._p_ic)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_capacitor::~COMMON_capacitor()
{
  --_count;
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_capacitor* p = dynamic_cast<const COMMON_capacitor*>(&x);
  return (p
    && _p_c == p->_p_c
    && _p_ic == p->_p_ic
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_capacitor::param_count() - 1 - I) {
  case 0:  _p_c = Value; break;
  case 1:  _p_ic = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
aidx COMMON_capacitor::set_param_by_name(std::string Name, std::string Value)
{
  if(Name == "$mfactor"){ Name = "m"; }
  static std::string names[] = {"c", "ic"  };
  int lb = 0;
  int ub = 2;
  while(lb < ub) {
    int mid = (lb+ub)/2;
    int c = std::strcmp(Name.c_str(), names[mid].c_str());
    if(c<0){
      ub = mid;
    }else if(c>0){
      lb = mid+1;
    }else{
      lb = mid;
      ub = 2;
      assert(lb<ub);
      break;
    }
  }
  assert(lb<=ub);
  switch(ub-lb){
    case 2:_p_c = Value;    break; // 0
    case 1:_p_ic = Value;    break; // 0
    case 0: return COMMON_COMPONENT::set_param_by_name(Name, Value); break;
  }
  return lb;
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::param_is_printable(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return (_p_c.has_hard_value());
  case 1:  return (_p_ic.has_hard_value());
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_name(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return "c";
  case 1:  return "ic";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_name(int i, int j)const
{
  if(j==0){
    return param_name(i);
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_value(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return _p_c.string();
  case 1:  return _p_ic.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::is_valid() const
{
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
  double lb, ub;
  {
  ddouble t0;
  t0 =  0.;
  lb = t0;
  }
  {
  ddouble t0;
  t0 =  Inf;
  ub = t0;
  }
  if(!(lb<=_p_c && _p_c<ub)){ return false; }else{ }
  }
  return true; //COMMON_COMPONENT::is_valid();
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_c),     def , par_scope);
  }
  {
    ddouble t0;
    t0 =  0.;
    real def = real(t0.value());
    e_val(&(this->_p_ic),     def , par_scope);
  }
  {
    ddouble t0;
    t0 = (_p_c) /*rhspar*/;
    real def = real(t0.value());
    this->_p___c = def;
  }
  {
    ddouble t0;
    t0 = (_p_ic) /*rhspar*/;
    real def = real(t0.value());
    this->_p___ic = def;
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_c),     def , par_scope);
  }
  {
    ddouble t0;
    t0 =  0.;
    real def = real(t0.value());
    e_val(&(this->_p_ic),     def , par_scope);
  }
  {
    ddouble t0;
    t0 = (_p_c) /*rhspar*/;
    real def = real(t0.value());
    this->_p___c = def;
  }
  {
    ddouble t0;
    t0 = (_p_ic) /*rhspar*/;
    real def = real(t0.value());
    this->_p___ic = def;
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int COMMON_capacitor::_count = -1;
static COMMON_capacitor Default_capacitor(CC_STATIC);
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
double MOD_capacitor::tr_probe_num(std::string const& n) const
{
  if(n == "conv") {
    return converged();
  }
  return BASE_SUBCKT::tr_probe_num(n);
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::read_probes()
{
  trace0("capacitor::read_probes");
  node_t gnd(&ground_node);
  // filter _b_ddt_2_p_ddt_2_n
  _potential_b_p_n = volts_limited(_n[n_p], _n[n_n]);
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::MOD_capacitor()
    :BASE_SUBCKT()
{
  _n = _nodes;
  attach_common(&Default_capacitor);
  ++_count;
  // build netlist
  // ports:2
  // overrides
}
/*--------------------------------------------------------------------------*/
// seq blocks
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::tr_needs_eval()const
{
  trace2("capacitor::needs_eval?", long_label(), has_probes());
  node_t gnd(&ground_node);
  if (is_q_for_eval()) { untested();
    return false;
  }else if (!converged()) {
    return true;
  }else if (has_probes()) {
    return true;
  }else   if(_sim->is_first_iteration()){
    return true;
  }else if( !conchk(_potential_b_p_n, _n[n_p].v0() - _n[n_n].v0(), 1e-6)){
    return true;
  }else{
    return false;
  }
};
/*--------------------------------------------------------------------------*/
#if 0
// tr_eval_branch _b_ddt_2_p_ddt_2_n
static EVAL__b_ddt_2_p_ddt_2_n_ Eval_(ddt_2_p, )(CC_STATIC);
void EVAL__b_ddt_2_p_ddt_2_n_::tr_eval(ELEMENT* d)const
{
  assert(d);
  auto* p = prechecked_cast<DEV_capacitor*>(d->owner());
  assert(p);
  const COMMON_capacitor* c = prechecked_cast<const COMMON_capacitor*>(p->common());
  assert(c);
  {
    { // 
// omit statement
    }
  }
}
/*--------------------------------------------------------------------------*/
// tr_eval_branch _b_p_n
static EVAL__b_p_n_ Eval_(p, n)(CC_STATIC);
void EVAL__b_p_n_::tr_eval(ELEMENT* d)const
{
  assert(d);
  auto* p = prechecked_cast<DEV_capacitor*>(d->owner());
  assert(p);
  const COMMON_capacitor* c = prechecked_cast<const COMMON_capacitor*>(p->common());
  assert(c);
  {
    { // 
// omit statement
    }
  }
}
/*--------------------------------------------------------------------------*/
#endif
bool MOD_capacitor::do_tr()
{
  trace3("capacitor::do_tr", this, long_label(), _sim->iteration_number());
  clear_branch_contributions();
  read_probes();
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  assert(c);
  set_converged();
  c->tr_eval_analog(this);
  set_branch_contributions();
  assert(subckt());
  set_converged(subckt()->do_tr() && converged());
  return converged();
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::zero_filter_readout()
{
  _potential_b_ddt_2_p_ddt_2_n = 0.;
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::set_branch_contributions()
{
    { // 1
    assert(_value_b_p_n == _value_b_p_n);
    _st_b_p_n[0] = _value_b_p_n;
    // sources...
      { // set state 
      long double sp = 0.;
      // _potential_b_ddt_2_p_ddt_2_n lin: 1
      sp += (long double)(_st_b_p_n[_st_b_p_n_::dep_potential_b_ddt_2_p_ddt_2_n] * _potential_b_ddt_2_p_ddt_2_n);
      _st_b_p_n[0] = double(_st_b_p_n[0] - sp);
      }
    }
  // pot src (p, n)
  if(!_b_p_n){ untested();
  }else if(_pot_b_p_n){
    _b_p_n->_loss0 = 1./OPT::shortckt;
  }else{
    _b_p_n->_loss0 = 0.; // AA
  }
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::clear_branch_contributions()
{
    _pot_b_p_n = false;
    _value_b_p_n = 0.;
    std::fill_n(_st_b_p_n+1, 2, 0.);
}
/*--------------------------------------------------------------------------*/
typedef MOD_capacitor::ddouble ddouble;
inline void COMMON_capacitor::tr_eval_analog(MOD_capacitor* d) const
{
  trace1("capacitor::tr_eval_analog", d);
  trace1("capacitor::tr_eval_analog", d->long_label());
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-local-typedefs"
#pragma GCC diagnostic pop
  MOD_capacitor const* p = d;
  assert(p);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    { // 
      {
        std::string s0;
        s0 = "ic";
        // function analysis 1
        ddouble t0;
        t0 =  /*(312)*/ /*call1*/_f_analysis(s0);
        t0 =  1. && t0;
        if (t0) {
          { // 
            { // Contribution V(p, n) lin: 1
              ddouble t0;
              t0 = (_p___ic) /*rhspar*/;
              if (!d->_pot_b_p_n){
                d->_pot_b_p_n = true;
                d->_value_b_p_n = 0.;
                std::fill_n(d->_st_b_p_n+1, 2, 0.);
              }else{
              }
              d->_value_b_p_n /* contrib sign: */ += t0.value();
            }
          }
        }else {
          { // 
            { // Contribution I(p, n) lin: 1
              ddouble t0;
              // t0[d_potential_b_ddt_2_p_ddt_2_n] = 0.; // (output dep)
              t0.set_no_deps();
              t0 = p->xs_potential_b_p_n();
              t0 = (_p___c) /*rhspar*/ * t0;
              // function ddt 1
              t0 =  /*(312)*/ /*call1*//*XDT*/ d->_b_ddt_2(t0);
              if (d->_pot_b_p_n){
                d->_pot_b_p_n = false;
                d->_value_b_p_n = 0.;
                std::fill_n(d->_st_b_p_n+1, 2, 0.);
              }else{
              }
              d->_value_b_p_n /* contrib sign: */ += t0.value();
              // dep _potential_b_ddt_2_p_ddt_2_n
              assert(t0[d_potential_b_ddt_2_p_ddt_2_n] == t0[d_potential_b_ddt_2_p_ddt_2_n]);
              d->_st_b_p_n[MOD::_st_b_p_n_::dep_potential_b_ddt_2_p_ddt_2_n] += t0[d_potential_b_ddt_2_p_ddt_2_n]; // (3)
            }
          }
        }

      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline void COMMON_capacitor::precalc_analog(MOD_capacitor* m) const
{
  MOD_capacitor const* p = m;
  assert(p);
  (void)p;
  COMMON_capacitor const* pc = this;
  (void)pc;
  PRECALC_capacitor P(m);
  PRECALC_capacitor* d = &P;
  (void)d;
  {
    { // 
      {
        std::string s0;
        s0 = "ic";
        // function analysis 1
        ddouble t0;
        t0 =  /*(312)*/ /*call1*/_f_analysis(s0);
        t0 =  1. && t0;
        if (t0) {
          { // 
            { // Contribution V(p, n) lin: 1
              ddouble t0;
              t0 = (_p___ic) /*rhspar*/;
            }
          }
        }else {
          { // 
            { // Contribution I(p, n) lin: 1
              ddouble t0;
              t0 = 0.; // static?
              t0 = (_p___c) /*rhspar*/ * t0;
              // function ddt 1
              t0 =  /*(312)*/ /*call1*//*XDT*/ d->_b_ddt_2(t0);
              // dep _potential_b_ddt_2_p_ddt_2_n
              m->_st_b_ddt_2_p_ddt_2_n[1] = - t0[d_potential_b_ddt_2_p_ddt_2_n]; // (3p)
            }
          }
        }

      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline TIME_PAIR MOD_capacitor::tr_review()
{
  {itested();
  }
  TIME_PAIR time_by = BASE_SUBCKT::tr_review();
  return time_by;
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::tr_accept()
{
  return BASE_SUBCKT::tr_accept();
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::tr_advance()
{
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  assert(c);
  if(_sim->_last_time == 0.){
  c->tr_eval_analog(this);
  }else{
  }
  set_not_converged();
  return BASE_SUBCKT::tr_advance();
}
/*--------------------------------------------------------------------------*/
  std::string MOD_capacitor::port_name(int i)const
{
    assert(i >= 0);
    assert(i < max_nodes());
    static std::string names[] = {"p", "n"    };
    return names[i];
  }
/*--------------------------------------------------------------------------*/
int MOD_capacitor::_count = -1;
MOD_capacitor m_capacitor;
DISPATCHER<CARD>::INSTALL d0(&device_dispatcher, "capacitor", &m_capacitor);
/*--------------------------------------------------------------------------*/
CARD* MOD_capacitor::clone()const
{
  MOD_capacitor* new_instance = new MOD_capacitor(*this);
  assert(!new_instance->subckt());
  return new_instance;
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::MOD_capacitor(MOD_capacitor const&p) : BASE_SUBCKT(p)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes(); ++ii) {
    _n[ii] = p._n[ii];
    }
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::precalc_first()
{
  BASE_SUBCKT::precalc_first();
  trace2("capacitor::pf", long_label(), mfactor());
  auto c = static_cast<COMMON_capacitor*>(mutable_common());
  assert(c);
  auto cc = c->clone();
  if(subckt()){
    attach_common(NULL);
    attach_common(cc);
    subckt()->precalc_first();
  }else{
  }
}
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::is_valid()const
{
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  return c->is_valid();
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::expand()
{
  trace1("expand", long_label());
  BASE_SUBCKT::expand();
  assert(_n);
  assert(common());
  auto c = static_cast</*const*/ COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  if (!subckt()) {
    new_subckt();
  }else{
  }

  node_t gnd;
  gnd.set_to_ground(this);
  // port p 1
  // port n 2
  // internal ddt_2_p : 3
  // node ddt_2_p 3
    //assert(!(_n[n_ddt_2_p].n_()));
    //BUG// this assert fails on a repeat elaboration after a change.
    //not sure of consequences when new_model_node called twice.
    if (!(_n[n_ddt_2_p].n_())) {
    if (_short_b_ddt_2()) {
      _n[n_ddt_2_p] = gnd;
    }else{
      _n[n_ddt_2_p].new_model_node("." + long_label() + ".ddt_2_p", this);
      }
    }else{
    {
       //_n[n_ddt_2_p].new_model_node("ddt_2_p." + long_label(), this);
    }
  }
  // ground
  _n[n_ddt_2_n].set_to_ground(this);
  if (_sim->is_first_expand()) {
    precalc_first();

  // clone branches
  // filter (ddt_2_p, )
    {
    if (!_b_ddt_2_p_ddt_2_n) {
      const CARD* p = device_dispatcher["va_ddt"]; // va_ddt
      if(!p){
        throw Exception("Cannot find va_ddt. Load module?");
      }else{
      }
      _b_ddt_2_p_ddt_2_n = dynamic_cast<ELEMENT*>(p->clone()); // elt
      if(!_b_ddt_2_p_ddt_2_n){
        throw Exception("Cannot use va_ddt: wrong type");
      }else{
      }
      subckt()->push_front(_b_ddt_2_p_ddt_2_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_ddt_2_p], gnd, _n[n_p], _n[n_n]}; // nodes
        _b_ddt_2_p_ddt_2_n->set_parameters("_b_ddt_2_p_ddt_2_n", this, _b_ddt_2_p_ddt_2_n->mutable_common(), 0., /*states:*/3, _st_b_ddt_2_p_ddt_2_n, 4, nodes);
      }
    }
  // branch (p, n)
    {
    if (!_b_p_n) {
      const CARD* p = device_dispatcher["va_sw"]; // va_sw
      if(!p){
        throw Exception("Cannot find va_sw. Load module?");
      }else{
      }
      _b_p_n = dynamic_cast<ELEMENT*>(p->clone()); // elt
      if(!_b_p_n){
        throw Exception("Cannot use va_sw: wrong type");
      }else{
      }
      subckt()->push_front(_b_p_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_p], _n[n_n], _n[n_ddt_2_p], gnd}; // nodes
        _b_p_n->set_parameters("_b_p_n", this, &_C_V_electrical, 0., /*states:*/3, _st_b_p_n, 4, nodes);
      }
    }

  // clone filters

  }else{
      //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
  for(CARD_LIST::iterator i=subckt()->begin(); i!=subckt()->end(); ++i){
    CARD* d = (*i)->deflate();
    if(d == (*i)){
    }else{
      assert(d->owner() == this);
      delete *i;
      *i = d;
    }
  }
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::precalc_last()
{
  BASE_SUBCKT::precalc_last();
  auto c = static_cast<COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  zero_filter_readout();
  c->precalc_analog(this);
  if(subckt()){
    subckt()->precalc_last();
  }else{untested();
  }
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::ddouble MOD_capacitor::_b_ddt_2(ddouble t0)
{
  MOD_capacitor* d = this;
  typedef MOD_capacitor MOD;
    d->_st_b_ddt_2_p_ddt_2_n[0] = + t0.value();
    // dep _potential_b_p_n
    assert(t0[d_potential_b_p_n] == t0[d_potential_b_p_n]);
    // assert(!d->_st_b_ddt_2_p_ddt_2_n[2]);
    d->_st_b_ddt_2_p_ddt_2_n[MOD::_st_b_ddt_2_p_ddt_2_n_::dep_potential_b_p_n]  = + t0[d_potential_b_p_n]; // (4)
  auto e = prechecked_cast<ELEMENT const*>(d->_b_ddt_2_p_ddt_2_n);
  assert(e);
  d->_potential_b_ddt_2_p_ddt_2_n = t0 = e->tr_amps(); // (236)
  t0[d_potential_b_ddt_2_p_ddt_2_n] = 1.;
  assert(t0 == t0);
  return t0; // (node)
}
/*--------------------------------------------------------------------------*/
}
/*--------------------------------------------------------------------------*/
}
/*--------------------------------------------------------------------------*/
