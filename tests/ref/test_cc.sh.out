/* This file is automatically generated. DO NOT EDIT */
/*--------------------------------------------------------------------------*/
#include <globals.h>
#include <e_compon.h>
#include <e_subckt.h>
#include <e_node.h>
#include <e_elemnt.h>
// #include <e_paramlist.h>
#include <u_nodemap.h>
#include <m_va.h>
#include <e_va.h>
#include <u_limit.h>
/*--------------------------------------------------------------------------*/
const double NA(NOT_INPUT);
const double INF(BIGBIG);
/*--------------------------------------------------------------------------*/
namespace {
/*--------------------------------------------------------------------------*/
class NATURE_Current : public NATURE {
  double abstol()const override {return 1e-12;}
}_N_Current;
class NATURE_Charge : public NATURE {
  double abstol()const override {return 1e-14;}
}_N_Charge;
class NATURE_Voltage : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Voltage;
class NATURE_Flux : public NATURE {
  double abstol()const override {return 1e-9;}
}_N_Flux;
class NATURE_Magneto_Motive_Force : public NATURE {
  double abstol()const override {return 1e-12;}
}_N_Magneto_Motive_Force;
class NATURE_Temperature : public NATURE {
  double abstol()const override {return 1e-4;}
}_N_Temperature;
class NATURE_Power : public NATURE {
  double abstol()const override {return 1e-9;}
}_N_Power;
class NATURE_Position : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Position;
class NATURE_Velocity : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Velocity;
class NATURE_Acceleration : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Acceleration;
class NATURE_Impulse : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Impulse;
class NATURE_Force : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Force;
class NATURE_Angle : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angle;
class NATURE_Angular_Velocity : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Velocity;
class NATURE_Angular_Acceleration : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Acceleration;
class NATURE_Angular_Force : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Force;
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
class DISCIPLINE_electrical : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Current;
  }
  NATURE const* potential()const override{
    return &_N_Voltage;
  }
}_D_electrical;
class _COMMON_VASRC_electrical : public COMMON_VASRC {
public:
  _COMMON_VASRC_electrical(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_electrical(_COMMON_VASRC_electrical const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_electrical(*this);
  }
  std::string name()const override{untested(); return "electrical";}
  DISCIPLINE const* discipline()const override {return &_D_electrical;}
public:
};
static _COMMON_VASRC_electrical _C_V_electrical(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_voltage : public DISCIPLINE {
public:
  NATURE const* potential()const override{
    return &_N_Voltage;
  }
}_D_voltage;
class _COMMON_VASRC_voltage : public COMMON_VASRC {
public:
  _COMMON_VASRC_voltage(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_voltage(_COMMON_VASRC_voltage const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_voltage(*this);
  }
  std::string name()const override{untested(); return "voltage";}
  DISCIPLINE const* discipline()const override {return &_D_voltage;}
public:
};
static _COMMON_VASRC_voltage _C_V_voltage(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_current : public DISCIPLINE {
public:
  NATURE const* potential()const override{
    return &_N_Current;
  }
}_D_current;
class _COMMON_VASRC_current : public COMMON_VASRC {
public:
  _COMMON_VASRC_current(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_current(_COMMON_VASRC_current const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_current(*this);
  }
  std::string name()const override{untested(); return "current";}
  DISCIPLINE const* discipline()const override {return &_D_current;}
public:
};
static _COMMON_VASRC_current _C_V_current(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_magnetic : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Flux;
  }
  NATURE const* potential()const override{
    return &_N_Magneto_Motive_Force;
  }
}_D_magnetic;
class _COMMON_VASRC_magnetic : public COMMON_VASRC {
public:
  _COMMON_VASRC_magnetic(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_magnetic(_COMMON_VASRC_magnetic const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_magnetic(*this);
  }
  std::string name()const override{untested(); return "magnetic";}
  DISCIPLINE const* discipline()const override {return &_D_magnetic;}
public:
};
static _COMMON_VASRC_magnetic _C_V_magnetic(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_thermal : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Power;
  }
  NATURE const* potential()const override{
    return &_N_Temperature;
  }
}_D_thermal;
class _COMMON_VASRC_thermal : public COMMON_VASRC {
public:
  _COMMON_VASRC_thermal(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_thermal(_COMMON_VASRC_thermal const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_thermal(*this);
  }
  std::string name()const override{untested(); return "thermal";}
  DISCIPLINE const* discipline()const override {return &_D_thermal;}
public:
};
static _COMMON_VASRC_thermal _C_V_thermal(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_kinematic : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Force;
  }
  NATURE const* potential()const override{
    return &_N_Position;
  }
}_D_kinematic;
class _COMMON_VASRC_kinematic : public COMMON_VASRC {
public:
  _COMMON_VASRC_kinematic(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_kinematic(_COMMON_VASRC_kinematic const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_kinematic(*this);
  }
  std::string name()const override{untested(); return "kinematic";}
  DISCIPLINE const* discipline()const override {return &_D_kinematic;}
public:
};
static _COMMON_VASRC_kinematic _C_V_kinematic(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_kinematic_v : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Force;
  }
  NATURE const* potential()const override{
    return &_N_Velocity;
  }
}_D_kinematic_v;
class _COMMON_VASRC_kinematic_v : public COMMON_VASRC {
public:
  _COMMON_VASRC_kinematic_v(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_kinematic_v(_COMMON_VASRC_kinematic_v const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_kinematic_v(*this);
  }
  std::string name()const override{untested(); return "kinematic_v";}
  DISCIPLINE const* discipline()const override {return &_D_kinematic_v;}
public:
};
static _COMMON_VASRC_kinematic_v _C_V_kinematic_v(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_rotational : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Angular_Force;
  }
  NATURE const* potential()const override{
    return &_N_Angle;
  }
}_D_rotational;
class _COMMON_VASRC_rotational : public COMMON_VASRC {
public:
  _COMMON_VASRC_rotational(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_rotational(_COMMON_VASRC_rotational const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_rotational(*this);
  }
  std::string name()const override{untested(); return "rotational";}
  DISCIPLINE const* discipline()const override {return &_D_rotational;}
public:
};
static _COMMON_VASRC_rotational _C_V_rotational(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_rotational_omega : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Angular_Force;
  }
  NATURE const* potential()const override{
    return &_N_Angular_Velocity;
  }
}_D_rotational_omega;
class _COMMON_VASRC_rotational_omega : public COMMON_VASRC {
public:
  _COMMON_VASRC_rotational_omega(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_rotational_omega(_COMMON_VASRC_rotational_omega const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_rotational_omega(*this);
  }
  std::string name()const override{untested(); return "rotational_omega";}
  DISCIPLINE const* discipline()const override {return &_D_rotational_omega;}
public:
};
static _COMMON_VASRC_rotational_omega _C_V_rotational_omega(CC_STATIC);
/*--------------------------------------------------------------------------*/
namespace n0{
class MOD_resistor;
class COMMON_resistor :public COMMON_COMPONENT{
  typedef MOD_resistor MOD;
  typedef ddouble_<1> ddouble;
  enum {
    d_potential_b_p_n,
     num_branches__  };
public:
  explicit COMMON_resistor(const COMMON_resistor& p);
  explicit COMMON_resistor(int c=0);
           ~COMMON_resistor();
  bool     operator==(const COMMON_COMPONENT&)const override;
  COMMON_COMPONENT* clone()const override {return new COMMON_resistor(*this);}
  void     set_param_by_index(int, std::string&, int)override;
  void     set_param_by_name(std::string, std::string)override;
  bool     is_valid()const;
  bool     param_is_printable(int)const override;
  std::string param_name(int)const override;
  std::string param_name(int,int)const override;
  std::string param_value(int)const override;
  int param_count()const override {return (1 + COMMON_COMPONENT::param_count());}
  void precalc_first(const CARD_LIST*)override;
  void expand(const COMPONENT*)override;
  void precalc_last(const CARD_LIST*)override;
  void tr_eval_analog(MOD_resistor*)const;
  std::string name()const override {itested();return "resistor";}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<real> _p_r /*  */;
private: // funcs
}; //COMMON_resistor
/*--------------------------------------------------------------------------*/
class MOD_resistor : public BASE_SUBCKT {
private:
  static int _count;
public:
  typedef ddouble_<1> ddouble;
  enum {
    d_potential_b_p_n,
     num_branches__  };
private: // data
  node_t _nodes[12];
public: // netlist
  ELEMENT* _b_p_n{NULL}; // branch
private: // func decl
private: // construct
  explicit MOD_resistor(MOD_resistor const&);
public:
  explicit MOD_resistor(); // : BASE_SUBCKT() { _n = _nodes; }
  CARD* clone()const override;
private: // overrides
  bool is_valid()const override;
  void precalc_first()override;
  void expand()override;
  void precalc_last()override;
  void zero_filter_readout();
  //void    map_nodes();         //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
  void    tr_load()override{ trace1("tr_load", long_label());BASE_SUBCKT::tr_load();}
  //TIME_PAIR  tr_review()override;         //BASE_SUBCKT
  //void    tr_accept()override;         //BASE_SUBCKT
  //void    tr_unload();         //BASE_SUBCKT
  void      dc_advance()override {set_not_converged(); BASE_SUBCKT::dc_advance();}
  void      tr_advance()override;
  void      tr_regress()override {set_not_converged(); BASE_SUBCKT::tr_regress();}
  bool      tr_needs_eval()const override;
  void      tr_queue_eval()override {if(tr_needs_eval()){q_eval();}else{} }
  bool      do_tr() override;
  double tr_probe_num(std::string const&)const override;
    //void    ac_begin();          //BASE_SUBCKT
    //void    do_ac();             //BASE_SUBCKT
    //void    ac_load();           //BASE_SUBCKT
    //XPROBE  ac_probe_ext(CS&)const;//CKT_BASE/nothing
  int max_nodes()const override {return 2;}
  int min_nodes()const override {return 2;}
  int int_nodes()const override    {return 0;}
  std::string value_name()const override {itested(); return "";}
  bool print_type_in_spice()const override {itested(); return false;}
  std::string port_name(int i)const override;
private: // impl
/* ========== */
public: // instance vars
private: // branch state
public: // states, _b_p_n;
  double _value_b_p_n;
  double _st_b_p_n  [2]; // (s)
  struct _st_b_p_n_ {
    enum {     VALUE, SELF/* : */
    };
  } _dep_b_p_n;
private: // node list
  enum {n_p, n_n  };
private: // probe values
  // double _potential_b_p_n;
  double _prb[1];
private: // impl
  void read_probes();
  void set_branch_contributions();
  void clear_branch_contributions();
  friend class COMMON_resistor;
}; // m_resistor;
/*--------------------------------------------------------------------------*/
COMMON_resistor::COMMON_resistor(int c)
  :COMMON_COMPONENT(c),
   _p_r(/*default*/)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_resistor::COMMON_resistor(const COMMON_resistor& p)
  :COMMON_COMPONENT(p),
   _p_r(p._p_r)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_resistor::~COMMON_resistor()
{
  --_count;
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_resistor* p = dynamic_cast<const COMMON_resistor*>(&x);
  return (p
    && _p_r == p->_p_r
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_resistor::param_count() - 1 - I) {
  case 0:  _p_r = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::set_param_by_name(std::string Name, std::string Value)
{
  if(Name == "$mfactor"){ Name = "m"; }
  static std::string names[] = {"r"  };
  int lb = 0;
  int ub = 1;
  while(lb < ub) {
    int mid = (lb+ub)/2;
    int c = std::strcmp(Name.c_str(), names[mid].c_str());
    if(c<0){
      ub = mid;
    }else if(c>0){
      lb = mid+1;
    }else{
      lb = mid;
      ub = 1;
      assert(lb<ub);
      break;
    }
  }
  assert(lb<=ub);
  switch(ub-lb){
    case 1:_p_r = Value;    break; // 0
    case 0: COMMON_COMPONENT::set_param_by_name(Name, Value); break;
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::param_is_printable(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return (_p_r.has_hard_value());
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_name(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return "r";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_name(int i, int j)const
{
  if(j==0){
    return param_name(i);
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_resistor::param_value(int i)const
{
  switch (COMMON_resistor::param_count() - 1 - i) {
  case 0:  return _p_r.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_resistor::is_valid() const
{
  COMMON_resistor const* pc = this;
  (void)pc;
  {
  double lb, ub;
  {
  ddouble t0;
  t0 =  10.E-9;
  lb = t0;
  }
  {
  ddouble t0;
  t0 =  Inf;
  ub = t0;
  }
  if(!(lb<=_p_r && _p_r<ub)){ return false; }else{ }
  }
  return true; //COMMON_COMPONENT::is_valid();
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_r),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_resistor::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_r),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int COMMON_resistor::_count = -1;
static COMMON_resistor Default_resistor(CC_STATIC);
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
double MOD_resistor::tr_probe_num(std::string const& n) const
{
  if(n == "conv") {
    return converged();
  }
  return BASE_SUBCKT::tr_probe_num(n)
;}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::read_probes()
{
  trace0("resistor::read_probes");
  node_t gnd(&ground_node);
  _prb[d_potential_b_p_n] = volts_limited(_n[n_p], _n[n_n]);
}
/*--------------------------------------------------------------------------*/
MOD_resistor::MOD_resistor()
    :BASE_SUBCKT()
{
  _n = _nodes;
  attach_common(&Default_resistor);
  ++_count;
  // build netlist
  // overrides
}
/*--------------------------------------------------------------------------*/
// seq blocks
/*--------------------------------------------------------------------------*/
bool MOD_resistor::tr_needs_eval()const
{
  node_t gnd(&ground_node);
  if (is_q_for_eval()) { untested();
    return false;
  }else if (!converged()) {
    return true;
  }else  if( !conchk(_prb[d_potential_b_p_n], _n[n_p].v0() - _n[n_n].v0(), 1e-6)){
    return true;
  }else{
    return false;
  }
};
/*--------------------------------------------------------------------------*/
bool MOD_resistor::do_tr()
{
  trace0("resistor::to_tr");
  clear_branch_contributions();
  read_probes();
  COMMON_resistor const* c = prechecked_cast<COMMON_resistor const*>(common());
  assert(c);
  set_converged();
  c->tr_eval_analog(this);
  set_branch_contributions();
  assert(subckt());
  set_converged(subckt()->do_tr() && converged());
  return converged();
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::zero_filter_readout()
{
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::set_branch_contributions()
{
  assert(_value_b_p_n == _value_b_p_n);
  _st_b_p_n[0] = _value_b_p_n;
  // collect currents from named branches
  // self_admittance
  _st_b_p_n[0] -= _st_b_p_n[1] * _prb[d_potential_b_p_n]; // (4)
  // flow src (p, n)
  // filters
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::clear_branch_contributions()
{
    _value_b_p_n = 0.;
    std::fill_n(_st_b_p_n+1, 1, 0.);
}
/*--------------------------------------------------------------------------*/
inline void COMMON_resistor::tr_eval_analog(MOD_resistor* d) const
{
  trace0("resistor::tr_eval_analog");
  MOD_resistor const* p = d;
  assert(p);
  COMMON_resistor const* pc = this;
  (void)pc;
  {
    { // 
      ddouble _v_i; // Variable       Dep: _potential_b_p_n      
      { // Assignment real 'i'.
        ddouble t0;
        t0 = +p->_prb[d_potential_b_p_n]; // V(p, n)
        t0[d_potential_b_p_n] = +1.;
        t0 = t0 / pc->_p_r;
        assert(t0.is_same(t0));
        _v_i = t0.value(); // (*)
        _v_i[d_potential_b_p_n] = t0[d_potential_b_p_n]; // (2b)
      }
      { // Contribution I(p, n)
        ddouble t0;
        t0 = _v_i;
        d->_value_b_p_n += t0.value();
        assert(t0[d_potential_b_p_n] == t0[d_potential_b_p_n]);
        d->_st_b_p_n[1] += t0[d_potential_b_p_n];
        // dep _potential_b_p_n
      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline void MOD_resistor::tr_advance()
{
  set_not_converged();
  return BASE_SUBCKT::tr_advance();
}
/*--------------------------------------------------------------------------*/
  std::string MOD_resistor::port_name(int i)const
{
    assert(i >= 0);
    assert(i < max_nodes());
    static std::string names[] = {"p", "n"    };
    return names[i];
  }
/*--------------------------------------------------------------------------*/
int MOD_resistor::_count = -1;
MOD_resistor m_resistor;
DISPATCHER<CARD>::INSTALL d0(&device_dispatcher, "resistor", &m_resistor);
/*--------------------------------------------------------------------------*/
CARD* MOD_resistor::clone()const
{
  MOD_resistor* new_instance = new MOD_resistor(*this);
  assert(!new_instance->subckt());
  return new_instance;
}
/*--------------------------------------------------------------------------*/
MOD_resistor::MOD_resistor(MOD_resistor const&p) : BASE_SUBCKT(p)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes(); ++ii) {
    _n[ii] = p._n[ii];
    }
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::precalc_first()
{
  BASE_SUBCKT::precalc_first();
  auto c = static_cast<COMMON_resistor*>(mutable_common());
  assert(c);
  (void)c;
  if(subckt()){
    subckt()->precalc_first();
  }else{
  }
}
/*--------------------------------------------------------------------------*/
bool MOD_resistor::is_valid()const
{
  COMMON_resistor const* c = prechecked_cast<COMMON_resistor const*>(common());
  return c->is_valid();
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::expand()
{
  BASE_SUBCKT::expand();
  assert(_n);
  assert(common());
  auto c = static_cast</*const*/ COMMON_resistor*>(mutable_common());
  assert(c);
  (void)c;
  if (!subckt()) {
    new_subckt();
  }else{
  }

  node_t gnd;
  gnd.set_to_ground(this);
  if (_sim->is_first_expand()) {
    precalc_first();
    precalc_last();
      // local nodes

  // clone branches
  // branch (p, n)
    {
    if (!_b_p_n) {
      const CARD* p = device_dispatcher["flow_src"]; // flow_src
      if(!p){
;        throw Exception("Cannot find flow_src. Load module?");
      }else{
      }
      _b_p_n = dynamic_cast<ELEMENT*>(p->clone());
      if(!_b_p_n){
        throw Exception("Cannot use flow_src: wrong type");
      }else{
      }
      subckt()->push_front(_b_p_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_p], _n[n_n]}; // nodes
        _b_p_n->set_parameters("_b_p_n", this, &_C_V_electrical, 0., /*states:*/2, _st_b_p_n, 2, nodes);
      }
    }

  // clone filters

  }else{
      //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
  subckt()->set_slave();
  for(CARD_LIST::iterator i=subckt()->begin(); i!=subckt()->end(); ++i){
    CARD* d = (*i)->deflate();
    if(d == (*i)){
    }else{
      assert(d->owner() == this);
      delete *i;
      *i = d;
    }
  }
}
/*--------------------------------------------------------------------------*/
void MOD_resistor::precalc_last()
{
  BASE_SUBCKT::precalc_last();
  auto c = static_cast<COMMON_resistor*>(mutable_common());
  assert(c);
  (void)c;
  zero_filter_readout();
  if(subckt()){
    subckt()->precalc_last();
  }else{untested();
  }
}
/*--------------------------------------------------------------------------*/
}
/*--------------------------------------------------------------------------*/
}
/*--------------------------------------------------------------------------*/
/* This file is automatically generated. DO NOT EDIT */
/*--------------------------------------------------------------------------*/
#include <globals.h>
#include <e_compon.h>
#include <e_subckt.h>
#include <e_node.h>
#include <e_elemnt.h>
// #include <e_paramlist.h>
#include <u_nodemap.h>
#include <m_va.h>
#include <e_va.h>
#include <u_limit.h>
/*--------------------------------------------------------------------------*/
const double NA(NOT_INPUT);
const double INF(BIGBIG);
/*--------------------------------------------------------------------------*/
namespace {
/*--------------------------------------------------------------------------*/
class NATURE_Current : public NATURE {
  double abstol()const override {return 1e-12;}
}_N_Current;
class NATURE_Charge : public NATURE {
  double abstol()const override {return 1e-14;}
}_N_Charge;
class NATURE_Voltage : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Voltage;
class NATURE_Flux : public NATURE {
  double abstol()const override {return 1e-9;}
}_N_Flux;
class NATURE_Magneto_Motive_Force : public NATURE {
  double abstol()const override {return 1e-12;}
}_N_Magneto_Motive_Force;
class NATURE_Temperature : public NATURE {
  double abstol()const override {return 1e-4;}
}_N_Temperature;
class NATURE_Power : public NATURE {
  double abstol()const override {return 1e-9;}
}_N_Power;
class NATURE_Position : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Position;
class NATURE_Velocity : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Velocity;
class NATURE_Acceleration : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Acceleration;
class NATURE_Impulse : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Impulse;
class NATURE_Force : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Force;
class NATURE_Angle : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angle;
class NATURE_Angular_Velocity : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Velocity;
class NATURE_Angular_Acceleration : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Acceleration;
class NATURE_Angular_Force : public NATURE {
  double abstol()const override {return 1e-6;}
}_N_Angular_Force;
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
class DISCIPLINE_electrical : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Current;
  }
  NATURE const* potential()const override{
    return &_N_Voltage;
  }
}_D_electrical;
class _COMMON_VASRC_electrical : public COMMON_VASRC {
public:
  _COMMON_VASRC_electrical(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_electrical(_COMMON_VASRC_electrical const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_electrical(*this);
  }
  std::string name()const override{untested(); return "electrical";}
  DISCIPLINE const* discipline()const override {return &_D_electrical;}
public:
};
static _COMMON_VASRC_electrical _C_V_electrical(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_voltage : public DISCIPLINE {
public:
  NATURE const* potential()const override{
    return &_N_Voltage;
  }
}_D_voltage;
class _COMMON_VASRC_voltage : public COMMON_VASRC {
public:
  _COMMON_VASRC_voltage(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_voltage(_COMMON_VASRC_voltage const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_voltage(*this);
  }
  std::string name()const override{untested(); return "voltage";}
  DISCIPLINE const* discipline()const override {return &_D_voltage;}
public:
};
static _COMMON_VASRC_voltage _C_V_voltage(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_current : public DISCIPLINE {
public:
  NATURE const* potential()const override{
    return &_N_Current;
  }
}_D_current;
class _COMMON_VASRC_current : public COMMON_VASRC {
public:
  _COMMON_VASRC_current(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_current(_COMMON_VASRC_current const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_current(*this);
  }
  std::string name()const override{untested(); return "current";}
  DISCIPLINE const* discipline()const override {return &_D_current;}
public:
};
static _COMMON_VASRC_current _C_V_current(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_magnetic : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Flux;
  }
  NATURE const* potential()const override{
    return &_N_Magneto_Motive_Force;
  }
}_D_magnetic;
class _COMMON_VASRC_magnetic : public COMMON_VASRC {
public:
  _COMMON_VASRC_magnetic(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_magnetic(_COMMON_VASRC_magnetic const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_magnetic(*this);
  }
  std::string name()const override{untested(); return "magnetic";}
  DISCIPLINE const* discipline()const override {return &_D_magnetic;}
public:
};
static _COMMON_VASRC_magnetic _C_V_magnetic(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_thermal : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Power;
  }
  NATURE const* potential()const override{
    return &_N_Temperature;
  }
}_D_thermal;
class _COMMON_VASRC_thermal : public COMMON_VASRC {
public:
  _COMMON_VASRC_thermal(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_thermal(_COMMON_VASRC_thermal const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_thermal(*this);
  }
  std::string name()const override{untested(); return "thermal";}
  DISCIPLINE const* discipline()const override {return &_D_thermal;}
public:
};
static _COMMON_VASRC_thermal _C_V_thermal(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_kinematic : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Force;
  }
  NATURE const* potential()const override{
    return &_N_Position;
  }
}_D_kinematic;
class _COMMON_VASRC_kinematic : public COMMON_VASRC {
public:
  _COMMON_VASRC_kinematic(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_kinematic(_COMMON_VASRC_kinematic const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_kinematic(*this);
  }
  std::string name()const override{untested(); return "kinematic";}
  DISCIPLINE const* discipline()const override {return &_D_kinematic;}
public:
};
static _COMMON_VASRC_kinematic _C_V_kinematic(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_kinematic_v : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Force;
  }
  NATURE const* potential()const override{
    return &_N_Velocity;
  }
}_D_kinematic_v;
class _COMMON_VASRC_kinematic_v : public COMMON_VASRC {
public:
  _COMMON_VASRC_kinematic_v(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_kinematic_v(_COMMON_VASRC_kinematic_v const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_kinematic_v(*this);
  }
  std::string name()const override{untested(); return "kinematic_v";}
  DISCIPLINE const* discipline()const override {return &_D_kinematic_v;}
public:
};
static _COMMON_VASRC_kinematic_v _C_V_kinematic_v(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_rotational : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Angular_Force;
  }
  NATURE const* potential()const override{
    return &_N_Angle;
  }
}_D_rotational;
class _COMMON_VASRC_rotational : public COMMON_VASRC {
public:
  _COMMON_VASRC_rotational(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_rotational(_COMMON_VASRC_rotational const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_rotational(*this);
  }
  std::string name()const override{untested(); return "rotational";}
  DISCIPLINE const* discipline()const override {return &_D_rotational;}
public:
};
static _COMMON_VASRC_rotational _C_V_rotational(CC_STATIC);
/*--------------------------------------------------------------------------*/
class DISCIPLINE_rotational_omega : public DISCIPLINE {
public:
  NATURE const* flow()const override{
    return &_N_Angular_Force;
  }
  NATURE const* potential()const override{
    return &_N_Angular_Velocity;
  }
}_D_rotational_omega;
class _COMMON_VASRC_rotational_omega : public COMMON_VASRC {
public:
  _COMMON_VASRC_rotational_omega(int i) : COMMON_VASRC(i){}
private:
  _COMMON_VASRC_rotational_omega(_COMMON_VASRC_rotational_omega const&p)     : COMMON_VASRC(p){}
  COMMON_COMPONENT* clone()const override{
    return new _COMMON_VASRC_rotational_omega(*this);
  }
  std::string name()const override{untested(); return "rotational_omega";}
  DISCIPLINE const* discipline()const override {return &_D_rotational_omega;}
public:
};
static _COMMON_VASRC_rotational_omega _C_V_rotational_omega(CC_STATIC);
/*--------------------------------------------------------------------------*/
namespace n0{
class MOD_capacitor;
class COMMON_capacitor :public COMMON_COMPONENT{
  typedef MOD_capacitor MOD;
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_0_,
    d_potential_b_p_n,
     num_branches__  };
public:
  explicit COMMON_capacitor(const COMMON_capacitor& p);
  explicit COMMON_capacitor(int c=0);
           ~COMMON_capacitor();
  bool     operator==(const COMMON_COMPONENT&)const override;
  COMMON_COMPONENT* clone()const override {return new COMMON_capacitor(*this);}
  void     set_param_by_index(int, std::string&, int)override;
  void     set_param_by_name(std::string, std::string)override;
  bool     is_valid()const;
  bool     param_is_printable(int)const override;
  std::string param_name(int)const override;
  std::string param_name(int,int)const override;
  std::string param_value(int)const override;
  int param_count()const override {return (1 + COMMON_COMPONENT::param_count());}
  void precalc_first(const CARD_LIST*)override;
  void expand(const COMPONENT*)override;
  void precalc_last(const CARD_LIST*)override;
  void tr_eval_analog(MOD_capacitor*)const;
  std::string name()const override {itested();return "capacitor";}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<real> _p_c /*  */;
private: // funcs
  class FILTER_b_ddt_0{
  public:
    ddouble operator()(ddouble t0, COMPONENT*) const;
  } _b_ddt_0;
}; //COMMON_capacitor
/*--------------------------------------------------------------------------*/
class MOD_capacitor : public BASE_SUBCKT {
private:
  static int _count;
public:
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_0_,
    d_potential_b_p_n,
     num_branches__  };
private: // data
  node_t _nodes[13];
public: // netlist
  // ELEMENT* _b_ddt_0_{NULL}; // no element (BUG)?
  ELEMENT* _b_p_n{NULL}; // branch
  ELEMENT* _b_ddt_0_{NULL};
private: // func decl
//filt _b_ddt_0
  ddouble _b_ddt_0(ddouble t0);
private: // construct
  explicit MOD_capacitor(MOD_capacitor const&);
public:
  explicit MOD_capacitor(); // : BASE_SUBCKT() { _n = _nodes; }
  CARD* clone()const override;
private: // overrides
  bool is_valid()const override;
  void precalc_first()override;
  void expand()override;
  void precalc_last()override;
  void zero_filter_readout();
  //void    map_nodes();         //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
  void    tr_load()override{ trace1("tr_load", long_label());BASE_SUBCKT::tr_load();}
  //TIME_PAIR  tr_review()override;         //BASE_SUBCKT
  //void    tr_accept()override;         //BASE_SUBCKT
  //void    tr_unload();         //BASE_SUBCKT
  void      dc_advance()override {set_not_converged(); BASE_SUBCKT::dc_advance();}
  void      tr_advance()override;
  void      tr_regress()override {set_not_converged(); BASE_SUBCKT::tr_regress();}
  bool      tr_needs_eval()const override;
  void      tr_queue_eval()override {if(tr_needs_eval()){q_eval();}else{} }
  bool      do_tr() override;
  double tr_probe_num(std::string const&)const override;
    //void    ac_begin();          //BASE_SUBCKT
    //void    do_ac();             //BASE_SUBCKT
    //void    ac_load();           //BASE_SUBCKT
    //XPROBE  ac_probe_ext(CS&)const;//CKT_BASE/nothing
  int max_nodes()const override {return 2;}
  int min_nodes()const override {return 2;}
  int int_nodes()const override    {return 1;}
  std::string value_name()const override {itested(); return "";}
  bool print_type_in_spice()const override {itested(); return false;}
  std::string port_name(int i)const override;
private: // impl
/* ========== */
public: // instance vars
private: // branch state
public: // states, _b_ddt_0_;
  double _value_b_ddt_0_;
  double _st_b_ddt_0_  [3]; // (s)
  struct _st_b_ddt_0__ {
    enum {     VALUE, SELF, dep_potential_b_p_n/* : */
    };
  } _dep_b_ddt_0_;
public: // states, _b_p_n;
  double _value_b_p_n;
  double _st_b_p_n  [3]; // (s)
  struct _st_b_p_n_ {
    enum {     VALUE, SELF, dep_potential_b_ddt_0_/* : */
    };
  } _dep_b_p_n;
  // filter_b_ddt_0_
private: // node list
  enum {n_p, n_n /* | */, n_ddt_0  };
private: // probe values
  // double _potential_b_ddt_0_;
  // double _potential_b_p_n;
  double _prb[2];
private: // impl
  void read_probes();
  void set_branch_contributions();
  void clear_branch_contributions();
  friend class COMMON_capacitor;
}; // m_capacitor;
/*--------------------------------------------------------------------------*/
COMMON_capacitor::COMMON_capacitor(int c)
  :COMMON_COMPONENT(c),
   _p_c(/*default*/)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_capacitor::COMMON_capacitor(const COMMON_capacitor& p)
  :COMMON_COMPONENT(p),
   _p_c(p._p_c)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_capacitor::~COMMON_capacitor()
{
  --_count;
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_capacitor* p = dynamic_cast<const COMMON_capacitor*>(&x);
  return (p
    && _p_c == p->_p_c
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_capacitor::param_count() - 1 - I) {
  case 0:  _p_c = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::set_param_by_name(std::string Name, std::string Value)
{
  if(Name == "$mfactor"){ Name = "m"; }
  static std::string names[] = {"c"  };
  int lb = 0;
  int ub = 1;
  while(lb < ub) {
    int mid = (lb+ub)/2;
    int c = std::strcmp(Name.c_str(), names[mid].c_str());
    if(c<0){
      ub = mid;
    }else if(c>0){
      lb = mid+1;
    }else{
      lb = mid;
      ub = 1;
      assert(lb<ub);
      break;
    }
  }
  assert(lb<=ub);
  switch(ub-lb){
    case 1:_p_c = Value;    break; // 0
    case 0: COMMON_COMPONENT::set_param_by_name(Name, Value); break;
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::param_is_printable(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return (_p_c.has_hard_value());
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_name(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return "c";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_name(int i, int j)const
{
  if(j==0){
    return param_name(i);
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_value(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return _p_c.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::is_valid() const
{
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
  double lb, ub;
  {
  ddouble t0;
  t0 =  0.;
  lb = t0;
  }
  {
  ddouble t0;
  t0 =  Inf;
  ub = t0;
  }
  if(!(lb<=_p_c && _p_c<ub)){ return false; }else{ }
  }
  return true; //COMMON_COMPONENT::is_valid();
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_c),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_c),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int COMMON_capacitor::_count = -1;
static COMMON_capacitor Default_capacitor(CC_STATIC);
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
double MOD_capacitor::tr_probe_num(std::string const& n) const
{
  if(n == "conv") {
    return converged();
  }
  return BASE_SUBCKT::tr_probe_num(n)
;}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::read_probes()
{
  trace0("capacitor::read_probes");
  node_t gnd(&ground_node);
  // filter _b_ddt_0_
  _prb[d_potential_b_p_n] = volts_limited(_n[n_p], _n[n_n]);
  // filter _b_ddt_0_
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::MOD_capacitor()
    :BASE_SUBCKT()
{
  _n = _nodes;
  attach_common(&Default_capacitor);
  ++_count;
  // build netlist
  // overrides
}
/*--------------------------------------------------------------------------*/
// seq blocks
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::tr_needs_eval()const
{
  node_t gnd(&ground_node);
  if (is_q_for_eval()) { untested();
    return false;
  }else if (!converged()) {
    return true;
  }else   if(_sim->is_first_iteration()){
    return true;
  }else if( !conchk(_prb[d_potential_b_p_n], _n[n_p].v0() - _n[n_n].v0(), 1e-6)){
    return true;
  }else{
    return false;
  }
};
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::do_tr()
{
  trace0("capacitor::to_tr");
  clear_branch_contributions();
  read_probes();
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  assert(c);
  set_converged();
  c->tr_eval_analog(this);
  set_branch_contributions();
  assert(subckt());
  set_converged(subckt()->do_tr() && converged());
  return converged();
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::zero_filter_readout()
{
  _prb[d_potential_b_ddt_0_] = 0.
;}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::set_branch_contributions()
{
  assert(_value_b_p_n == _value_b_p_n);
  _st_b_p_n[0] = _value_b_p_n;
  // collect currents from named branches
<<<<<<< HEAD
  _st_b_p_n[0] -= _st_b_p_n[/*MOD::*/_st_b_p_n_::dep_potential_b_ddt_0_] * _potential_b_ddt_0_;
=======
<<<<<<< HEAD
<<<<<<< HEAD
  // trace2(" filter _st_b_p_n", _st_b_p_n[2], __filter_b_ddt_0_);
  // assert(2  ==  /*MOD::*/_st_b_p_n_::dep__filter_b_ddt_0_);
  _st_b_p_n[0] += _st_b_p_n[/*MOD::*/_st_b_p_n_::dep__filter_b_ddt_0_] * _b_ddt_0_->tr_amps();
=======
  _st_b_p_n[0] -= _st_b_p_n[/*MOD::*/_st_b_p_n_::dep_potential_b_ddt_0_] * _potential_b_ddt_0_;
>>>>>>> 9c868e1 (refactor probes)
=======
  _st_b_p_n[0] -= _st_b_p_n[_st_b_p_n_::dep_potential_b_ddt_0_] * _prb[d_potential_b_ddt_0_]; // (583)
>>>>>>> 2ad80d5 (cont'd)
>>>>>>> 3bcebea (cont'd)
  // flow src (p, n)
  // filters
  // filter _b_ddt_0_
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::clear_branch_contributions()
{
    _value_b_p_n = 0.;
    std::fill_n(_st_b_p_n+1, 2, 0.);
    // std::fill_n(_st_b_ddt_0_, 3, 0.);
}
/*--------------------------------------------------------------------------*/
inline void COMMON_capacitor::tr_eval_analog(MOD_capacitor* d) const
{
  trace0("capacitor::tr_eval_analog");
  MOD_capacitor const* p = d;
  assert(p);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    { // 
      { // Contribution I(p, n)
        ddouble t0;
        t0 = +p->_prb[d_potential_b_p_n]; // V(p, n)
        t0[d_potential_b_p_n] = +1.;
        // function ddt 1
        t0 =  /*(312)*/ /*call1*//*XDT*/ d->_b_ddt_0(t0);
        t0 = pc->_p_c * t0;
        d->_value_b_p_n += t0.value();
        // dep _potential_b_ddt_0_
        assert(t0[d_potential_b_ddt_0_] == t0[d_potential_b_ddt_0_]);
        assert(MOD::_st_b_p_n_::dep_potential_b_ddt_0_ < 3);
        d->_st_b_p_n[MOD::_st_b_p_n_::dep_potential_b_ddt_0_] += t0[d_potential_b_ddt_0_]; // (3)
      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::tr_advance()
{
  set_not_converged();
  return BASE_SUBCKT::tr_advance();
}
/*--------------------------------------------------------------------------*/
  std::string MOD_capacitor::port_name(int i)const
{
    assert(i >= 0);
    assert(i < max_nodes());
    static std::string names[] = {"p", "n"    };
    return names[i];
  }
/*--------------------------------------------------------------------------*/
int MOD_capacitor::_count = -1;
MOD_capacitor m_capacitor;
DISPATCHER<CARD>::INSTALL d0(&device_dispatcher, "capacitor", &m_capacitor);
/*--------------------------------------------------------------------------*/
CARD* MOD_capacitor::clone()const
{
  MOD_capacitor* new_instance = new MOD_capacitor(*this);
  assert(!new_instance->subckt());
  return new_instance;
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::MOD_capacitor(MOD_capacitor const&p) : BASE_SUBCKT(p)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes(); ++ii) {
    _n[ii] = p._n[ii];
    }
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::precalc_first()
{
  BASE_SUBCKT::precalc_first();
  auto c = static_cast<COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  if(subckt()){
    subckt()->precalc_first();
  }else{
  }
}
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::is_valid()const
{
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  return c->is_valid();
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::expand()
{
  BASE_SUBCKT::expand();
  assert(_n);
  assert(common());
  auto c = static_cast</*const*/ COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  if (!subckt()) {
    new_subckt();
  }else{
  }

  node_t gnd;
  gnd.set_to_ground(this);
  if (_sim->is_first_expand()) {
    precalc_first();
    precalc_last();
      // local nodes
    //assert(!(_n[n_ddt_0].n_()));
    //BUG// this assert fails on a repeat elaboration after a change.
    //not sure of consequences when new_model_node called twice.
    if (!(_n[n_ddt_0].n_())) {
  {
        _n[n_ddt_0].new_model_node("." + long_label() + ".ddt_0", this);
      }
    }else{
  {
        //_n[n_ddt_0].new_model_node("ddt_0." + long_label(), this);
      }
    }

  // clone branches
  // branch no elt (ddt_0, )
  // branch (p, n)
    {
    if (!_b_p_n) {
      const CARD* p = device_dispatcher["flow_src"]; // flow_src
      if(!p){
;        throw Exception("Cannot find flow_src. Load module?");
      }else{
      }
      _b_p_n = dynamic_cast<ELEMENT*>(p->clone());
      if(!_b_p_n){
        throw Exception("Cannot use flow_src: wrong type");
      }else{
      }
      subckt()->push_front(_b_p_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_p], _n[n_n], _n[n_ddt_0], gnd}; // nodes
        _b_p_n->set_parameters("_b_p_n", this, &_C_V_electrical, 0., /*states:*/3, _st_b_p_n, 4, nodes);
      }
    }

  // clone filters
  // ddt_0
{ // filter expand
    // code_name _b_ddt_0_
    if (!_b_ddt_0_) {
      const CARD* p = device_dispatcher["va_ddt"];
      if(!p){
;        throw Exception("Cannot find va_ddt. Load module?");
      }else{
      }
      _b_ddt_0_ = dynamic_cast<ELEMENT*>(p->clone());
      if(!_b_ddt_0_){
        throw Exception("Cannot use va_ddt: wrong type");
      }else{
      }
      subckt()->push_front(_b_ddt_0_);
    }else{
    }
      {
        node_t nodes[] = {_n[n_ddt_0], gnd, _n[n_p], _n[n_n]};
        _b_ddt_0_->set_parameters("ddt_0", this, _b_ddt_0_->mutable_common(), 0., /*states:*/3, _st_b_ddt_0_, 4, nodes);
      }
    }

  }else{
      //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
  subckt()->set_slave();
  for(CARD_LIST::iterator i=subckt()->begin(); i!=subckt()->end(); ++i){
    CARD* d = (*i)->deflate();
    if(d == (*i)){
    }else{
      assert(d->owner() == this);
      delete *i;
      *i = d;
    }
  }
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::precalc_last()
{
  BASE_SUBCKT::precalc_last();
  auto c = static_cast<COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  zero_filter_readout();
  if(subckt()){
    subckt()->precalc_last();
  }else{untested();
  }
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::ddouble MOD_capacitor::_b_ddt_0(ddouble t0)
{
  MOD_capacitor* d = this;
  typedef MOD_capacitor MOD;
    d->_st_b_ddt_0_[0] = + t0.value();
    // dep _potential_b_p_n
    assert(t0[d_potential_b_p_n] == t0[d_potential_b_p_n]);
    // assert(!d->_st_b_ddt_0_[2]);
    d->_st_b_ddt_0_[MOD::_st_b_ddt_0__::dep_potential_b_p_n]  = + t0[d_potential_b_p_n]; // (4)
  d->_b_ddt_0_->do_tr();
  t0 = d->_b_ddt_0_->tr_amps();
<<<<<<< HEAD
  d->_potential_b_ddt_0_ = - t0;
=======
  d->_prb[d_potential_b_ddt_0_] = t0;
>>>>>>> 3bcebea (cont'd)
  trace2("filt", t0, d->_b_ddt_0_->tr_outvolts());
  t0[d_potential_b_ddt_0_] = -1.;
  assert(t0 == t0);
  return t0;
}
}
namespace n1{
class MOD_capacitor;
class COMMON_capacitor :public COMMON_COMPONENT{
  typedef MOD_capacitor MOD;
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_1_,
    d_potential_b_p_n,
     num_branches__  };
public:
  explicit COMMON_capacitor(const COMMON_capacitor& p);
  explicit COMMON_capacitor(int c=0);
           ~COMMON_capacitor();
  bool     operator==(const COMMON_COMPONENT&)const override;
  COMMON_COMPONENT* clone()const override {return new COMMON_capacitor(*this);}
  void     set_param_by_index(int, std::string&, int)override;
  void     set_param_by_name(std::string, std::string)override;
  bool     is_valid()const;
  bool     param_is_printable(int)const override;
  std::string param_name(int)const override;
  std::string param_name(int,int)const override;
  std::string param_value(int)const override;
  int param_count()const override {return (2 + COMMON_COMPONENT::param_count());}
  void precalc_first(const CARD_LIST*)override;
  void expand(const COMPONENT*)override;
  void precalc_last(const CARD_LIST*)override;
  void tr_eval_analog(MOD_capacitor*)const;
  std::string name()const override {itested();return "capacitor";}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<real> _p_c /*  */;
  PARAMETER<real> _p_ic /*  */;
private: // funcs
  double _f_analysis(std::string const& what)const {
    if(what=="ic"){
      return _sim->analysis_is_tran_static();
    }else if(what=="static"){
      return _sim->analysis_is_static();
    }else{ untested();
      incomplete();
      return false;
    }
  }
  class FILTER_b_ddt_1{
  public:
    ddouble operator()(ddouble t0, COMPONENT*) const;
  } _b_ddt_1;
}; //COMMON_capacitor
/*--------------------------------------------------------------------------*/
class MOD_capacitor : public BASE_SUBCKT {
private:
  static int _count;
public:
  typedef ddouble_<2> ddouble;
  enum {
    d_potential_b_ddt_1_,
    d_potential_b_p_n,
     num_branches__  };
private: // data
  node_t _nodes[13];
public: // netlist
  // ELEMENT* _b_ddt_1_{NULL}; // no element (BUG)?
  ELEMENT* _b_p_n{NULL}; // branch
  ELEMENT* _b_ddt_1_{NULL};
private: // func decl
//func analysis
  // analysis
//filt _b_ddt_1
  ddouble _b_ddt_1(ddouble t0);
private: // construct
  explicit MOD_capacitor(MOD_capacitor const&);
public:
  explicit MOD_capacitor(); // : BASE_SUBCKT() { _n = _nodes; }
  CARD* clone()const override;
private: // overrides
  bool is_valid()const override;
  void precalc_first()override;
  void expand()override;
  void precalc_last()override;
  void zero_filter_readout();
  //void    map_nodes();         //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
  void    tr_load()override{ trace1("tr_load", long_label());BASE_SUBCKT::tr_load();}
  TIME_PAIR  tr_review()override;         //BASE_SUBCKT
  void    tr_accept()override;         //BASE_SUBCKT
  //void    tr_unload();         //BASE_SUBCKT
  void      dc_advance()override {set_not_converged(); BASE_SUBCKT::dc_advance();}
  void      tr_advance()override;
  void      tr_regress()override {set_not_converged(); BASE_SUBCKT::tr_regress();}
  bool      tr_needs_eval()const override;
  void      tr_queue_eval()override {if(tr_needs_eval()){q_eval();}else{} }
  bool      do_tr() override;
  double tr_probe_num(std::string const&)const override;
    //void    ac_begin();          //BASE_SUBCKT
    //void    do_ac();             //BASE_SUBCKT
    //void    ac_load();           //BASE_SUBCKT
    //XPROBE  ac_probe_ext(CS&)const;//CKT_BASE/nothing
  int max_nodes()const override {return 2;}
  int min_nodes()const override {return 2;}
  int int_nodes()const override    {return 1;}
  std::string value_name()const override {itested(); return "";}
  bool print_type_in_spice()const override {itested(); return false;}
  std::string port_name(int i)const override;
private: // impl
/* ========== */
public: // instance vars
private: // branch state
public: // states, _b_ddt_1_;
  double _value_b_ddt_1_;
  double _st_b_ddt_1_  [3]; // (s)
  struct _st_b_ddt_1__ {
    enum {     VALUE, SELF, dep_potential_b_p_n/* : */
    };
  } _dep_b_ddt_1_;
public: // states, _b_p_n;
  bool _pot_b_p_n;
  double _value_b_p_n;
  double _st_b_p_n  [3]; // (s)
  struct _st_b_p_n_ {
    enum {     VALUE, SELF, dep_potential_b_ddt_1_/* : */
    };
  } _dep_b_p_n;
  // filter_b_ddt_1_
private: // node list
  enum {n_p, n_n /* | */, n_ddt_1  };
private: // probe values
  // double _potential_b_ddt_1_;
  // double _potential_b_p_n;
  double _prb[2];
private: // impl
  void read_probes();
  void set_branch_contributions();
  void clear_branch_contributions();
  friend class COMMON_capacitor;
}; // m_capacitor;
/*--------------------------------------------------------------------------*/
COMMON_capacitor::COMMON_capacitor(int c)
  :COMMON_COMPONENT(c),
   _p_c(/*default*/),
   _p_ic(/*default*/)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_capacitor::COMMON_capacitor(const COMMON_capacitor& p)
  :COMMON_COMPONENT(p),
   _p_c(p._p_c),
   _p_ic(p._p_ic)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_capacitor::~COMMON_capacitor()
{
  --_count;
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_capacitor* p = dynamic_cast<const COMMON_capacitor*>(&x);
  return (p
    && _p_c == p->_p_c
    && _p_ic == p->_p_ic
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_capacitor::param_count() - 1 - I) {
  case 0:  _p_c = Value; break;
  case 1:  _p_ic = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::set_param_by_name(std::string Name, std::string Value)
{
  if(Name == "$mfactor"){ Name = "m"; }
  static std::string names[] = {"c", "ic"  };
  int lb = 0;
  int ub = 2;
  while(lb < ub) {
    int mid = (lb+ub)/2;
    int c = std::strcmp(Name.c_str(), names[mid].c_str());
    if(c<0){
      ub = mid;
    }else if(c>0){
      lb = mid+1;
    }else{
      lb = mid;
      ub = 2;
      assert(lb<ub);
      break;
    }
  }
  assert(lb<=ub);
  switch(ub-lb){
    case 2:_p_c = Value;    break; // 0
    case 1:_p_ic = Value;    break; // 0
    case 0: COMMON_COMPONENT::set_param_by_name(Name, Value); break;
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::param_is_printable(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return (_p_c.has_hard_value());
  case 1:  return (_p_ic.has_hard_value());
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_name(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return "c";
  case 1:  return "ic";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_name(int i, int j)const
{
  if(j==0){
    return param_name(i);
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_capacitor::param_value(int i)const
{
  switch (COMMON_capacitor::param_count() - 1 - i) {
  case 0:  return _p_c.string();
  case 1:  return _p_ic.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_capacitor::is_valid() const
{
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
  double lb, ub;
  {
  ddouble t0;
  t0 =  0.;
  lb = t0;
  }
  {
  ddouble t0;
  t0 =  Inf;
  ub = t0;
  }
  if(!(lb<=_p_c && _p_c<ub)){ return false; }else{ }
  }
  return true; //COMMON_COMPONENT::is_valid();
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_c),     def , par_scope);
  }
  {
    ddouble t0;
    t0 =  0.;
    real def = real(t0.value());
    e_val(&(this->_p_ic),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_capacitor::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    ddouble t0;
    t0 =  1.;
    real def = real(t0.value());
    e_val(&(this->_p_c),     def , par_scope);
  }
  {
    ddouble t0;
    t0 =  0.;
    real def = real(t0.value());
    e_val(&(this->_p_ic),     def , par_scope);
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int COMMON_capacitor::_count = -1;
static COMMON_capacitor Default_capacitor(CC_STATIC);
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
double MOD_capacitor::tr_probe_num(std::string const& n) const
{
  if(n == "conv") {
    return converged();
  }
  return BASE_SUBCKT::tr_probe_num(n)
;}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::read_probes()
{
  trace0("capacitor::read_probes");
  node_t gnd(&ground_node);
  // filter _b_ddt_1_
  _prb[d_potential_b_p_n] = volts_limited(_n[n_p], _n[n_n]);
  // filter _b_ddt_1_
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::MOD_capacitor()
    :BASE_SUBCKT()
{
  _n = _nodes;
  attach_common(&Default_capacitor);
  ++_count;
  // build netlist
  // overrides
}
/*--------------------------------------------------------------------------*/
// seq blocks
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::tr_needs_eval()const
{
  node_t gnd(&ground_node);
  if (is_q_for_eval()) { untested();
    return false;
  }else if (!converged()) {
    return true;
  }else   if(_sim->is_first_iteration()){
    return true;
  }else if( !conchk(_prb[d_potential_b_p_n], _n[n_p].v0() - _n[n_n].v0(), 1e-6)){
    return true;
  }else{
    return false;
  }
};
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::do_tr()
{
  trace0("capacitor::to_tr");
  clear_branch_contributions();
  read_probes();
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  assert(c);
  set_converged();
  c->tr_eval_analog(this);
  set_branch_contributions();
  assert(subckt());
  set_converged(subckt()->do_tr() && converged());
  return converged();
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::zero_filter_readout()
{
  _prb[d_potential_b_ddt_1_] = 0.
;}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::set_branch_contributions()
{
  assert(_value_b_p_n == _value_b_p_n);
  _st_b_p_n[0] = _value_b_p_n;
<<<<<<< HEAD
  _st_b_p_n[0] -= _st_b_p_n[/*MOD::*/_st_b_p_n_::dep_potential_b_ddt_1_] * _potential_b_ddt_1_;
=======
<<<<<<< HEAD
<<<<<<< HEAD
  // trace2(" filter _st_b_p_n", _st_b_p_n[2], __filter_b_ddt_1_);
  // assert(2  ==  /*MOD::*/_st_b_p_n_::dep__filter_b_ddt_1_);
  _st_b_p_n[0] += _st_b_p_n[/*MOD::*/_st_b_p_n_::dep__filter_b_ddt_1_] * _b_ddt_1_->tr_amps();
=======
  _st_b_p_n[0] -= _st_b_p_n[/*MOD::*/_st_b_p_n_::dep_potential_b_ddt_1_] * _potential_b_ddt_1_;
>>>>>>> 9c868e1 (refactor probes)
=======
  _st_b_p_n[0] -= _st_b_p_n[_st_b_p_n_::dep_potential_b_ddt_1_] * _prb[d_potential_b_ddt_1_]; // (583)
>>>>>>> 2ad80d5 (cont'd)
>>>>>>> 3bcebea (cont'd)
  // pot src (p, n)
  if(!_b_p_n){ untested();
  }else if(_pot_b_p_n){
    _b_p_n->_loss0 = 1./OPT::shortckt;
  }else{
    _b_p_n->_loss0 = 0.;
  }
  // filters
  // filter _b_ddt_1_
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::clear_branch_contributions()
{
    _pot_b_p_n = false;
    _value_b_p_n = 0.;
    std::fill_n(_st_b_p_n+1, 2, 0.);
    // std::fill_n(_st_b_ddt_1_, 3, 0.);
}
/*--------------------------------------------------------------------------*/
inline void COMMON_capacitor::tr_eval_analog(MOD_capacitor* d) const
{
  trace0("capacitor::tr_eval_analog");
  MOD_capacitor const* p = d;
  assert(p);
  COMMON_capacitor const* pc = this;
  (void)pc;
  {
    { // 
      {
        std::string s0;
        s0 = "ic";
        // function analysis 1
        ddouble t0;
        t0 =  /*(312)*/ /*call1*/_f_analysis(s0);
        if (t0) {
          { // Contribution V(p, n)
            ddouble t0;
            t0 = pc->_p_ic;
            if (!d->_pot_b_p_n){
              d->_pot_b_p_n = true;
              d->_value_b_p_n = 0.;
              std::fill_n(d->_st_b_p_n+1, 2, 0.);
            }else{
            }
            d->_value_b_p_n += t0.value();
          }
        }else {
          { // Contribution I(p, n)
            ddouble t0;
            t0 = +p->_prb[d_potential_b_p_n]; // V(p, n)
            t0[d_potential_b_p_n] = +1.;
            // function ddt 1
            t0 =  /*(312)*/ /*call1*//*XDT*/ d->_b_ddt_1(t0);
            t0 = pc->_p_c * t0;
            if (d->_pot_b_p_n){
              d->_pot_b_p_n = false;
              d->_value_b_p_n = 0.;
              std::fill_n(d->_st_b_p_n+1, 2, 0.);
            }else{
            }
            d->_value_b_p_n += t0.value();
            // dep _potential_b_ddt_1_
            assert(t0[d_potential_b_ddt_1_] == t0[d_potential_b_ddt_1_]);
            assert(MOD::_st_b_p_n_::dep_potential_b_ddt_1_ < 3);
            d->_st_b_p_n[MOD::_st_b_p_n_::dep_potential_b_ddt_1_] += t0[d_potential_b_ddt_1_]; // (3)
          }
        }

      }
    }
  }
}
/*--------------------------------------------------------------------------*/
inline TIME_PAIR MOD_capacitor::tr_review()
{
  {itested();
  }
  return BASE_SUBCKT::tr_review();
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::tr_accept()
{
  return BASE_SUBCKT::tr_accept();
}
/*--------------------------------------------------------------------------*/
inline void MOD_capacitor::tr_advance()
{
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  assert(c);
  if(_sim->_last_time == 0.){
  c->tr_eval_analog(this);
  }else{
  }
  set_not_converged();
  return BASE_SUBCKT::tr_advance();
}
/*--------------------------------------------------------------------------*/
  std::string MOD_capacitor::port_name(int i)const
{
    assert(i >= 0);
    assert(i < max_nodes());
    static std::string names[] = {"p", "n"    };
    return names[i];
  }
/*--------------------------------------------------------------------------*/
int MOD_capacitor::_count = -1;
MOD_capacitor m_capacitor;
DISPATCHER<CARD>::INSTALL d0(&device_dispatcher, "capacitor", &m_capacitor);
/*--------------------------------------------------------------------------*/
CARD* MOD_capacitor::clone()const
{
  MOD_capacitor* new_instance = new MOD_capacitor(*this);
  assert(!new_instance->subckt());
  return new_instance;
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::MOD_capacitor(MOD_capacitor const&p) : BASE_SUBCKT(p)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes(); ++ii) {
    _n[ii] = p._n[ii];
    }
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::precalc_first()
{
  BASE_SUBCKT::precalc_first();
  auto c = static_cast<COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  if(subckt()){
    subckt()->precalc_first();
  }else{
  }
}
/*--------------------------------------------------------------------------*/
bool MOD_capacitor::is_valid()const
{
  COMMON_capacitor const* c = prechecked_cast<COMMON_capacitor const*>(common());
  return c->is_valid();
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::expand()
{
  BASE_SUBCKT::expand();
  assert(_n);
  assert(common());
  auto c = static_cast</*const*/ COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  if (!subckt()) {
    new_subckt();
  }else{
  }

  node_t gnd;
  gnd.set_to_ground(this);
  if (_sim->is_first_expand()) {
    precalc_first();
    precalc_last();
      // local nodes
    //assert(!(_n[n_ddt_1].n_()));
    //BUG// this assert fails on a repeat elaboration after a change.
    //not sure of consequences when new_model_node called twice.
    if (!(_n[n_ddt_1].n_())) {
  {
        _n[n_ddt_1].new_model_node("." + long_label() + ".ddt_1", this);
      }
    }else{
  {
        //_n[n_ddt_1].new_model_node("ddt_1." + long_label(), this);
      }
    }

  // clone branches
  // branch no elt (ddt_1, )
  // branch (p, n)
    {
    if (!_b_p_n) {
      const CARD* p = device_dispatcher["va_pot"]; // va_pot
      if(!p){
;        throw Exception("Cannot find va_pot. Load module?");
      }else{
      }
      _b_p_n = dynamic_cast<ELEMENT*>(p->clone());
      if(!_b_p_n){
        throw Exception("Cannot use va_pot: wrong type");
      }else{
      }
      subckt()->push_front(_b_p_n);
    }else{
    }
      {
        node_t nodes[] = {_n[n_p], _n[n_n], _n[n_ddt_1], gnd}; // nodes
        _b_p_n->set_parameters("_b_p_n", this, &_C_V_electrical, 0., /*states:*/3, _st_b_p_n, 4, nodes);
      }
    }

  // clone filters
  // ddt_1
{ // filter expand
    // code_name _b_ddt_1_
    if (!_b_ddt_1_) {
      const CARD* p = device_dispatcher["va_ddt"];
      if(!p){
;        throw Exception("Cannot find va_ddt. Load module?");
      }else{
      }
      _b_ddt_1_ = dynamic_cast<ELEMENT*>(p->clone());
      if(!_b_ddt_1_){
        throw Exception("Cannot use va_ddt: wrong type");
      }else{
      }
      subckt()->push_front(_b_ddt_1_);
    }else{
    }
      {
        node_t nodes[] = {_n[n_ddt_1], gnd, _n[n_p], _n[n_n]};
        _b_ddt_1_->set_parameters("ddt_1", this, _b_ddt_1_->mutable_common(), 0., /*states:*/3, _st_b_ddt_1_, 4, nodes);
      }
    }

  }else{
      //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
  subckt()->set_slave();
  for(CARD_LIST::iterator i=subckt()->begin(); i!=subckt()->end(); ++i){
    CARD* d = (*i)->deflate();
    if(d == (*i)){
    }else{
      assert(d->owner() == this);
      delete *i;
      *i = d;
    }
  }
}
/*--------------------------------------------------------------------------*/
void MOD_capacitor::precalc_last()
{
  BASE_SUBCKT::precalc_last();
  auto c = static_cast<COMMON_capacitor*>(mutable_common());
  assert(c);
  (void)c;
  zero_filter_readout();
  if(subckt()){
    subckt()->precalc_last();
  }else{untested();
  }
}
/*--------------------------------------------------------------------------*/
MOD_capacitor::ddouble MOD_capacitor::_b_ddt_1(ddouble t0)
{
  MOD_capacitor* d = this;
  typedef MOD_capacitor MOD;
    d->_st_b_ddt_1_[0] = + t0.value();
    // dep _potential_b_p_n
    assert(t0[d_potential_b_p_n] == t0[d_potential_b_p_n]);
    // assert(!d->_st_b_ddt_1_[2]);
    d->_st_b_ddt_1_[MOD::_st_b_ddt_1__::dep_potential_b_p_n]  = + t0[d_potential_b_p_n]; // (4)
  d->_b_ddt_1_->do_tr();
  t0 = d->_b_ddt_1_->tr_amps();
<<<<<<< HEAD
  d->_potential_b_ddt_1_ = - t0;
=======
  d->_prb[d_potential_b_ddt_1_] = t0;
>>>>>>> 3bcebea (cont'd)
  trace2("filt", t0, d->_b_ddt_1_->tr_outvolts());
  t0[d_potential_b_ddt_1_] = -1.;
  assert(t0 == t0);
  return t0;
}
}
/*--------------------------------------------------------------------------*/
}
/*--------------------------------------------------------------------------*/
