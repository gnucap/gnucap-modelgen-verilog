== plain.gc

Basic instanciation and transient. Run with

$ gnucap plain.gc
[..]

== compiled.gc

Same as plain.gc, but using a compiled model. Compile with

$ gnucap-mg-vams --cc rc.vams | g++ -xc++ `gnucap-conf --cppflags` -fPIC -shared - -o rc.so

Now run

$ gnucap compiled.gc
[..]

== behavioural.gc

Same, formulated as behavioural model in rc_b.vams. Uses "analog" block.

$ gnucap-mg-vams --cc rc_b.vams | g++ -xc++ `gnucap-conf --cppflags` -fPIC -shared - -o rc_b.so
$ gnucap behavioural.gc

== paramset.gc

Sometimes it is useful to create a new prototype that has parameters fixed in
one way or another. With rc_b.so compiled as above, run

$ gnucap paramset.gc
[..] model=2 [..]

You see two instances of rc, with an initial value ic=2 in each of them.

== compiled_ps.gc

Sometimes it is useful to know constants during compilation. For this purpose,
Verilog-AMS defines "paramset".

$ gnucap-mg-vams --cc rc_ps.vams | g++ -xc++ `gnucap-conf --cppflags` -fPIC -shared - -o rc_ps.so
$ gnucap compiled_ps.gc
[..] model=1 [..]

Note the second instance of rc_ps, without "ic" set. It does not use an
internal node, because it resolves to the simpler one that does not take an
"ic" parameter.

== Laplace filter example

Verilog-AMS defines s-domain filters, laplace_{nd,np,zd,zp}. Those are
equivalent to linear networks, see LRM Section 4.5.11. Here's a simple
example.

$ gnucap-mg-vams --cc rc_lap.vams | g++ -xc++ `gnucap-conf --cppflags` -fPIC -shared - -o rc_lap.so
$ gnucap rc_lap.gc
[.. data]

== Inverse Z filter lowpass

Sometimes it is useful to be able to design discrete filters. Verilog-AMS
defines the zi_{nd,np,zd,zp} family of filter functions to aid this. See LRM
Section 4.5.12.

Here's a small example lowpass filter, see the comments in rc_zi.gc for
details, and run the simulation to compare against the ordinary linear rc.

$ gnucap-mg-vams --cc rc_zi.vams | g++ -xc++ `gnucap-conf --cppflags` -fPIC -shared - -o rc_zi.so
$ gnucap rc_zi.gc
[.. data]

